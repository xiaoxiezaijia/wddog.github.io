{"meta":{"title":"帅气的狗头","subtitle":null,"description":"我们敲代码的不懂这些，，，","author":"xiaoxie","url":"http://blog.wddog.cn"},"pages":[{"title":"categories","date":"2018-03-06T03:49:36.000Z","updated":"2018-03-06T03:49:58.542Z","comments":false,"path":"categories/index.html","permalink":"http://blog.wddog.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-06T03:47:23.000Z","updated":"2018-03-06T03:48:26.655Z","comments":false,"path":"tags/index.html","permalink":"http://blog.wddog.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"php设计模式 Bridge (桥接模式)","slug":"设计模式 bridge (桥接模式)","date":"2018-06-19T14:01:50.629Z","updated":"2018-06-19T14:02:47.481Z","comments":true,"path":"2018/06/19/设计模式 bridge (桥接模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式 bridge (桥接模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式中的 Bridge (桥接模式)示例代码，感兴趣的同学参考研究下。 将抽象部份与它实现部分分离,使用它们都可以有独立的变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php /** * 桥接模式 * * 将抽象部份与它实现部分分离,使用它们都可以有独立的变化 */ abstract class Implementor &#123; abstract public function operation(); &#125; class ConcreteImplementorA extends Implementor &#123; public function operation() &#123; echo \"ConcreteImplementorA Operation&lt;br/&gt;\"; &#125; &#125; class ConcreteImplementorB extends Implementor &#123; public function operation() &#123; echo \"ConcreteImplementorB Operation&lt;br/&gt;\"; &#125; &#125;class Abstraction &#123; protected $_implementor = null; public function setImplementor($implementor) &#123; $this-&gt;_implementor = $implementor; &#125; public function operation() &#123; $this-&gt;_implementor-&gt;operation(); &#125; &#125; class RefinedAbstraction extends Abstraction &#123; &#125; class ExampleAbstraction extends Abstraction &#123; &#125; // $objRAbstraction = new RefinedAbstraction(); $objRAbstraction-&gt;setImplementor(new ConcreteImplementorB()); $objRAbstraction-&gt;operation(); $objRAbstraction-&gt;setImplementor(new ConcreteImplementorA()); $objRAbstraction-&gt;operation(); $objEAbstraction = new ExampleAbstraction(); $objEAbstraction-&gt;setImplementor(new ConcreteImplementorB()); $objEAbstraction-&gt;operation();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式 Chain Of Responsibility (职责链模式)","slug":"设计模式 Chain Of Responsibility (职责链模式)","date":"2018-06-19T13:56:37.479Z","updated":"2018-06-19T14:00:06.136Z","comments":true,"path":"2018/06/19/设计模式 Chain Of Responsibility (职责链模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式 Chain Of Responsibility (职责链模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式中的 Chain Of Responsibility (职责链模式)示例代码，感兴趣的同学参考下。 为解除请求的发送者和接收者之间的耦合,而使用多个对象都用机会处理这个请求,将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php /** * 职责链模式 * * 为解除请求的发送者和接收者之间的耦合,而使用多个对象都用机会处理这个请求,将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它 * */ abstract class Handler &#123; protected $_handler = null; public function setSuccessor($handler) &#123; $this-&gt;_handler = $handler; &#125; abstract function handleRequest($request); &#125; class ConcreteHandlerZero extends Handler &#123; public function handleRequest($request) &#123; if($request == 0) &#123; echo \"0&lt;br/&gt;\"; &#125; else &#123; $this-&gt;_handler-&gt;handleRequest($request); &#125; &#125; &#125; class ConcreteHandlerOdd extends Handler &#123; public function handleRequest($request) &#123; if($request % 2) &#123; echo $request.\" is odd&lt;br/&gt;\"; &#125; else &#123; $this-&gt;_handler-&gt;handleRequest($request); &#125; &#125; &#125; class ConcreteHandlerEven extends Handler &#123; public function handleRequest($request) &#123; if(!($request % 2)) &#123; echo $request.\" is even&lt;br/&gt;\"; &#125; else &#123; $this-&gt;_handler-&gt;handleRequest($request); &#125; &#125; &#125; // 实例一下 $objZeroHander = new ConcreteHandlerZero(); $objEvenHander = new ConcreteHandlerEven(); $objOddHander = new ConcreteHandlerOdd(); $objZeroHander-&gt;setSuccessor($objEvenHander); $objEvenHander-&gt;setSuccessor($objOddHander); foreach(array(2,3,4,5,0) as $row) &#123; $objZeroHander-&gt;handleRequest($row); &#125;","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式 FlyWeight (享元模式)","slug":"设计模式-flyWeight (享元模式)","date":"2018-06-19T13:53:45.110Z","updated":"2018-06-19T13:56:32.001Z","comments":true,"path":"2018/06/19/设计模式-flyWeight (享元模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-flyWeight (享元模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式中的 FlyWeight (享元模式)示例代码，感兴趣的同学参考学习下。 享元模式英文称为“Flyweight Pattern”，我非常感谢将Flyweight Pattern翻译成享元模式的那位强人，因为这个词将这个模式使用的方式明白得表示了出来；如果翻译成为羽量级模式或者蝇量级模式等等，虽然可以含蓄的表现出使用此模式达到的目的，但是还是没有抓住此模式的关键。 享元模式的定义为：采用一个共享来避免大量拥有相同内容对象的开销。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式高效的支持大量的细粒度对象。 在名字和定义中都体现出了共享这一个核心概念，那么怎么来实现共享呢？要知道每个事物都是不同的，但是又有一定的共性，如果只有完全相同的事物才能共享，那么享元模式可以说就是不可行的；因此我们应该尽量将事物的共性共享，而又保留它的个性。为了做到这点，享元模式中区分了内蕴状态和外蕴状态。内蕴状态就是共性，外蕴状态就是个性了。 注：共享的对象必须是不可变的，不然一变则全变（如果有这种需求除外）。 内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象出来。 先看看下面程序，大概了解下享元模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php /** * 享元模式 * * 运用享元技术有效的支持大量细粒度的对象 */ class CD &#123; private $_title = null; private $_artist = null; public function setTitle($title) &#123; $this-&gt;_title = $title; &#125; public function getTitle() &#123; return $this-&gt;_title; &#125; public function setArtist($artist) &#123; $this-&gt;_artist = $artist; &#125; public function getArtist($artist) &#123; return $this-&gt;_artist; &#125; &#125; class Artist &#123; private $_name; public function __construct($name) &#123; echo \"construct \".$name.\"&lt;br/&gt;\"; $this-&gt;_name = $name; &#125; public function getName() &#123; return $this-&gt;_name; &#125; &#125; class ArtistFactory &#123; private $_artists = array(); public function getArtist($name) &#123; if(isset($this-&gt;_artists[$name])) &#123; return $this-&gt;_artists[$name]; &#125; else &#123; $objArtist = new Artist($name); $this-&gt;_artists[$name] = $objArtist; return $objArtist; &#125; &#125; &#125; $objArtistFactory = new ArtistFactory(); $objCD1 = new CD(); $objCD1-&gt;setTitle(\"title1\"); $objCD1-&gt;setArtist($objArtistFactory-&gt;getArtist('artist1')); $objCD2 = new CD(); $objCD2-&gt;setTitle(\"title2\"); $objCD2-&gt;setArtist($objArtistFactory-&gt;getArtist('artist2')); $objCD3 = new CD(); $objCD3-&gt;setTitle(\"title3\"); $objCD3-&gt;setArtist($objArtistFactory-&gt;getArtist('artist1')); 享元模式的精要有三点： 被系统大量使用的细粒度对象，粒度要有多细，量要有多大，看看jdk中使用的享元模式就知道了，jdk中，Integer,Character,String等都使用了享元模式，他们都是最基础的数据类型，不可谓不细，他们频繁的参与运算，不可谓不大量。划分对象的内蕴属性/状态和外蕴属性/状态;所谓内蕴状态，就是存在对象的内部，不会随着环境变化的状态， 有一个网友说的很好，就是无区别的状态， 即拿掉外蕴属性之后同一类对象没有区别对象的内蕴状态就是对象的元神，只要元神元神无区别，那么对象也就无区别，同时也只有这些无区别的元神可以被共享，我想这也是Flyweight被翻译成享元的原因。外蕴状态就是由客户端指定，会随着环境变化的状态; 对于Integer来说， 他的内蕴属性其实就是他的value(当然它也没有外蕴属性);用一个工厂控制享元的创造;因为享元对象不能被客户端随意创造， 否则就没有意义了。工厂通常提供缓存机制保存已经创造的享元。面向对象虽然很好地解决了抽象性的问题，但是对于一个实际运行的软件系统，我们还需要考虑面向对象的代价问题，享元模式解决的就是面向对象的代价问题。享元模式采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。 享元模式在一般的项目开发中并不常用，而是常常应用于系统底层的开发，以便解决系统的性能问题。Java和.Net中的String类型就是使用了享元模式。如果在Java或者.NET中已经创建了一个字符串对象s1，那么下次再创建相同的字符串s2的时候，系统只是把s2的引用指向s1所引用的具体对象，这就实现了相同字符串在内存中的共享。如果每次执行s1=“abc”操作的时候，都创建一个新的字符串对象的话，那么内存的开销会很大。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Mediator (中介者模式)","slug":"设计模式-mediator (中介者模式)","date":"2018-06-19T13:52:25.362Z","updated":"2018-06-19T13:53:26.248Z","comments":true,"path":"2018/06/19/设计模式-mediator (中介者模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-mediator (中介者模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式 中的Mediator (中介者模式)示例代码，感兴趣的同学参考学习下。 用一个中介对象来封装一系列的对象交互,使各对象不需要显式地相互引用从而使其耦合松散,而且可以独立地改变它们之间的交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php /** * 中介者模式 * * 用一个中介对象来封装一系列的对象交互,使各对象不需要显式地相互引用从而使其耦合松散,而且可以独立地改变它们之间的交互 */ abstract class Mediator &#123; abstract public function send($message,$colleague); &#125; abstract class Colleague &#123; private $_mediator = null; public function Colleague($mediator) &#123; $this-&gt;_mediator = $mediator; &#125; public function send($message) &#123; $this-&gt;_mediator-&gt;send($message,$this); &#125; abstract public function notify($message); &#125; class ConcreteMediator extends Mediator &#123; private $_colleague1 = null; private $_colleague2 = null; public function send($message,$colleague) &#123; if($colleague == $this-&gt;_colleague1) &#123; $this-&gt;_colleague1-&gt;notify($message); &#125; else &#123; $this-&gt;_colleague2-&gt;notify($message); &#125; &#125; public function set($colleague1,$colleague2) &#123; $this-&gt;_colleague1 = $colleague1; $this-&gt;_colleague2 = $colleague2; &#125; &#125; class Colleague1 extends Colleague &#123; public function notify($message) &#123; echo \"Colleague1 Message is :\".$message.\"&lt;br/&gt;\"; &#125; &#125; class Colleague2 extends Colleague &#123; public function notify($message) &#123; echo \"Colleague2 Message is :\".$message.\"&lt;br/&gt;\"; &#125; &#125; // $objMediator = new ConcreteMediator(); $objC1 = new Colleague1($objMediator); $objC2 = new Colleague2($objMediator); $objMediator-&gt;set($objC1,$objC2); $objC1-&gt;send(\"to c2 from c1\"); $objC2-&gt;send(\"to c1 from c2\");","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Prototype原型模式","slug":"设计模式-prototype原型模式","date":"2018-06-19T13:47:45.220Z","updated":"2018-06-19T13:50:23.832Z","comments":true,"path":"2018/06/19/设计模式-prototype原型模式/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-prototype原型模式/","excerpt":"","text":"用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。Prototype原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。 用原型实例指定创建对象的种类.并且通过拷贝这个原型来创建新的对象 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php /** * 原型模式 * * 用原型实例指定创建对象的种类.并且通过拷贝这个原型来创建新的对象 * */ abstract class Prototype &#123; private $_id = null; public function __construct($id) &#123; $this-&gt;_id = $id; &#125; public function getID() &#123; return $this-&gt;_id; &#125; public function __clone() // magic function &#123; $this-&gt;_id += 1; &#125; public function getClone() &#123; return clone $this; &#125; &#125; class ConcretePrototype extends Prototype &#123; &#125; // $objPrototype = new ConcretePrototype(0); $objPrototype1 = clone $objPrototype; echo $objPrototype1-&gt;getID().\"&lt;br/&gt;\"; $objPrototype2 = $objPrototype; echo $objPrototype2-&gt;getID().\"&lt;br/&gt;\"; $objPrototype3 = $objPrototype-&gt;getClone(); echo $objPrototype3-&gt;getID().\"&lt;br/&gt;\";","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Visitor 访问者模式","slug":"设计模式-visitor 访问者模式","date":"2018-06-19T13:45:10.002Z","updated":"2018-06-19T13:46:08.664Z","comments":true,"path":"2018/06/19/设计模式-visitor 访问者模式/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-visitor 访问者模式/","excerpt":"","text":"本文为大家讲解的是php设计模式 中的Visitor 访问者模式，感兴趣的同学参考下。 表示一个作用于某对象结构中的各元素的操作,可以在不改变各元素的类的前提下定义作用于这些元素的新操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?php /** * 访问者模式 * * 表示一个作用于某对象结构中的各元素的操作,可以在不改变各元素的类的前提下定义作用于这些元素的新操作 * */ abstract class Visitor &#123; abstract public function visitCroncreteElementA($element); abstract public function visitCroncreteElementB($element); &#125; class ConcreteVisitor1 extends Visitor &#123; public function visitCroncreteElementA($element) &#123; echo get_class($element).\" visit 1A&lt;br/&gt;\"; &#125; public function visitCroncreteElementB($element) &#123; echo get_class($element).\" visit 1B&lt;br/&gt;\"; &#125; &#125; class ConcreteVisitor2 extends Visitor &#123; public function visitCroncreteElementA($element) &#123; echo get_class($element).\" visit 2A&lt;br/&gt;\"; &#125; public function visitCroncreteElementB($element) &#123; echo get_class($element).\" visit 2B&lt;br/&gt;\"; &#125; &#125; abstract class Element &#123; abstract public function accept($visitor); &#125; class ConcreteElementA extends Element &#123; public function accept($visitor) &#123; $visitor-&gt;visitCroncreteElementA($this); &#125; &#125; class ConcreteElementB extends Element &#123; public function accept($visitor) &#123; $visitor-&gt;visitCroncreteElementB($this); &#125; &#125; class ObjectStructure &#123; private $_elements = array(); public function attach($element) &#123; $this-&gt;_elements[] = $element; &#125; public function detach($element) &#123; if($key = array_search($element,$this-&gt;_elements) !== false) unset($this-&gt;_elements[$key]); &#125; public function accept($visitor) &#123; foreach($this-&gt;_elements as $element) &#123; $element-&gt;accept($visitor); &#125; &#125; &#125; // $objOS = new ObjectStructure(); $objOS-&gt;attach(new ConcreteElementA()); $objOS-&gt;attach(new ConcreteElementB()); $objCV1 = new ConcreteVisitor1(); $objCV2 = new ConcreteVisitor2(); $objOS-&gt;accept($objCV1); $objOS-&gt;accept($objCV2);","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Adapter(适配器模式)","slug":"设计模式-adapter(适配器模式)","date":"2018-06-19T13:41:31.132Z","updated":"2018-06-19T13:43:26.704Z","comments":true,"path":"2018/06/19/设计模式-adapter(适配器模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-adapter(适配器模式)/","excerpt":"","text":"本文为大家讲解的是php设计模式 中的Adapter(适配器模式)示例代码，感兴趣的同学参考下。 将一个类的接口转换成客户希望的另外一个接口,使用原本不兼容的而不能在一起工作的那些类可以在一起工作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php /** * 适配器模式 * * 将一个类的接口转换成客户希望的另外一个接口,使用原本不兼容的而不能在一起工作的那些类可以在一起工作 */ // 这个是原有的类型 class OldCache &#123; public function __construct() &#123; echo \"OldCache construct&lt;br/&gt;\"; &#125; public function store($key,$value) &#123; echo \"OldCache store&lt;br/&gt;\"; &#125; public function remove($key) &#123; echo \"OldCache remove&lt;br/&gt;\"; &#125; public function fetch($key) &#123; echo \"OldCache fetch&lt;br/&gt;\"; &#125; &#125; interface Cacheable &#123; public function set($key,$value); public function get($key); public function del($key); &#125; class OldCacheAdapter implements Cacheable &#123; private $_cache = null; public function __construct() &#123; $this-&gt;_cache = new OldCache(); &#125; public function set($key,$value) &#123; return $this-&gt;_cache-&gt;store($key,$value); &#125; public function get($key) &#123; return $this-&gt;_cache-&gt;fetch($key); &#125; public function del($key) &#123; return $this-&gt;_cache-&gt;remove($key); &#125; &#125; $objCache = new OldCacheAdapter(); $objCache-&gt;set(\"test\",1); $objCache-&gt;get(\"test\"); $objCache-&gt;del(\"test\",1);","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式 Builder(建造者模式)","slug":"设计模式-builder(建造者模式)","date":"2018-06-19T13:36:32.592Z","updated":"2018-06-19T13:40:59.240Z","comments":true,"path":"2018/06/19/设计模式-builder(建造者模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-builder(建造者模式)/","excerpt":"","text":"本文为大家提供的是php设计模式中的 Builder(建造者模式)示例代码，感兴趣的同学参考下。 将一个复杂对象的构建与它的表示分离,使用同样的构建过程可以创建不同的表示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php /** * 建造者模式 * * 将一个复杂对象的构建与它的表示分离,使用同样的构建过程可以创建不同的表示 */ class Product &#123; public $_type = null; public $_size = null; public $_color = null; public function setType($type) &#123; echo \"set product type&lt;br/&gt;\"; $this-&gt;_type = $type; &#125; public function setSize($size) &#123; echo \"set product size&lt;br/&gt;\"; $this-&gt;_size = $size; &#125; public function setColor($color) &#123; echo \"set product color&lt;br/&gt;\"; $this-&gt;_color = $color; &#125; &#125; $config = array( \"type\"=&gt;\"shirt\", \"size\"=&gt;\"xl\", \"color\"=&gt;\"red\", ); // 没有使用bulider以前的处理 $oProduct = new Product(); $oProduct-&gt;setType($config['type']); $oProduct-&gt;setSize($config['size']); $oProduct-&gt;setColor($config['color']); // 创建一个builder类 class ProductBuilder &#123; $_config = null; $_object = null; public function ProductBuilder($config) &#123; $this-&gt;_object = new Product(); $this-&gt;_config = $config; &#125; public function build() &#123; echo \"--- in builder---&lt;br/&gt;\"; $this-&gt;_object-&gt;setType($this-&gt;_config['type']); $this-&gt;_object-&gt;setSize($this-&gt;_config['size']); $this-&gt;_object-&gt;setColor($this-&gt;_config['color']); &#125; public function getProduct() &#123; return $this-&gt;_object; &#125; &#125; $objBuilder = new ProductBuilder($config); $objBuilder-&gt;build(); $objProduct = $objBuilder-&gt;getProduct();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式 DAO(数据访问对象模式)","slug":"设计模式-dao(数据访问对象模式)","date":"2018-06-19T13:33:30.762Z","updated":"2018-06-19T13:35:42.664Z","comments":true,"path":"2018/06/19/设计模式-dao(数据访问对象模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-dao(数据访问对象模式)/","excerpt":"","text":"本文为大家提供的是php设计模式 中的DAO(数据访问对象模式)示例代码，感兴趣的同学参考下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php /** * 数据访问对象(Data Access Object) 示例 * * @create_date: 2010-01-04 */ class BaseDAO &#123; $_db = null; $_table = null; function BaseDAO($config) &#123; $this-&gt;_db = new MysqlDB(); // 这里的不能进行操作 &#125; /** * 获取处理 * * @param array $filter // 过滤条件 * @param string $field // 获取字段 * @param int $page // 当前页 * @param int $limit // 页数 */ function fetch($filter = array(),$field = \"*\",$page = 1,$limit = null) &#123; $this-&gt;_db-&gt;select($filed)-&gt;from($this-&gt;_table)-&gt;where($filter)-&gt;limit($page,$limit); return $this-&gt;_db-&gt;execute(); &#125; function update()&#123;&#125; function delete()&#123;&#125; function insert()&#123;&#125; &#125; class MemberDAO extends BaseDAO &#123; $_table = \"member\"; &#125; $oMember = new MemberDAO(); $oMember-&gt;fetch(); /** * 常用到的地方: * MVC中model层基类 */","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Decorator(装饰模式)","slug":"设计模式-decorator(装饰模式)","date":"2018-06-19T13:31:05.085Z","updated":"2018-06-19T13:33:15.657Z","comments":true,"path":"2018/06/19/设计模式-decorator(装饰模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-decorator(装饰模式)/","excerpt":"","text":"本文为大家讲解的是php设计模式中的 Decorator(装饰模式)示例代码，感兴趣的同学参考下 动态的给一个对象添加一些额外的职责,就扩展功能而言比生成子类方式更为灵活 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php /** * 装饰模式 * * 动态的给一个对象添加一些额外的职责,就扩展功能而言比生成子类方式更为灵活 */ header(\"Content-type:text/html;charset=utf-8\"); abstract class MessageBoardHandler &#123; public function __construct()&#123;&#125; abstract public function filter($msg); &#125; class MessageBoard extends MessageBoardHandler &#123; public function filter($msg) &#123; return \"处理留言板上的内容|\".$msg; &#125; &#125; $obj = new MessageBoard(); echo $obj-&gt;filter(\"一定要学好装饰模式&lt;br/&gt;\"); // --- 以下是使用装饰模式 ---- class MessageBoardDecorator extends MessageBoardHandler &#123; private $_handler = null; public function __construct($handler) &#123; parent::__construct(); $this-&gt;_handler = $handler; &#125; public function filter($msg) &#123; return $this-&gt;_handler-&gt;filter($msg); &#125; &#125; // 过滤html class HtmlFilter extends MessageBoardDecorator &#123; public function __construct($handler) &#123; parent::__construct($handler); &#125; public function filter($msg) &#123; return \"过滤掉HTML标签|\".parent::filter($msg);; // 过滤掉HTML标签的处理 这时只是加个文字 没有进行处理 &#125; &#125; // 过滤敏感词 class SensitiveFilter extends MessageBoardDecorator &#123; public function __construct($handler) &#123; parent::__construct($handler); &#125; public function filter($msg) &#123; return \"过滤掉敏感词|\".parent::filter($msg); // 过滤掉敏感词的处理 这时只是加个文字 没有进行处理 &#125; &#125; $obj = new HtmlFilter(new SensitiveFilter(new MessageBoard())); echo $obj-&gt;filter(\"一定要学好装饰模式!&lt;br/&gt;\");","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Delegation(委托模式)","slug":"设计模式-delegation(委托模式)","date":"2018-06-19T13:28:25.463Z","updated":"2018-06-19T13:39:26.024Z","comments":true,"path":"2018/06/19/设计模式-delegation(委托模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-delegation(委托模式)/","excerpt":"","text":"本文为大家讲解的是php设计模式中的 Delegation 委托模式示例代码，需要的朋友可以参考下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php /** * 委托模式 示例 * * @create_date: 2010-01-04 */ class PlayList &#123; $_songs = array(); $_object = null; function PlayList($type) &#123; $object = $type.\"PlayListDelegation\"; $this-&gt;_object = new $object(); &#125; function addSong($location,$title) &#123; $this-&gt;_songs[] = array(\"location\"=&gt;$location,\"title\"=&gt;$title); &#125; function getPlayList() &#123; return $this-&gt;_object-&gt;getPlayList($this-&gt;_songs); &#125; &#125; class mp3PlayListDelegation &#123; function getPlayList($songs) &#123; $aResult = array(); foreach($songs as $key=&gt;$item) &#123; $path = pathinfo($item['location']); if(strtolower($item['extension']) == \"mp3\") &#123; $aResult[] = $item; &#125; &#125; return $aResult; &#125; &#125; class rmvbPlayListDelegation &#123; function getPlayList($songs) &#123; $aResult = array(); foreach($songs as $key=&gt;$item) &#123; $path = pathinfo($item['location']); if(strtolower($item['extension']) == \"rmvb\") &#123; $aResult[] = $item; &#125; &#125; return $aResult; &#125; &#125; $oMP3PlayList = new PlayList(\"mp3\"); $oMP3PlayList-&gt;getPlayList(); $oRMVBPlayList = new PlayList(\"rmvb\"); $oRMVBPlayList-&gt;getPlayList();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Facade(外观模式)","slug":"设计模式-facade(外观模式)","date":"2018-06-19T13:21:10.893Z","updated":"2018-06-19T13:27:47.784Z","comments":true,"path":"2018/06/19/设计模式-facade(外观模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-facade(外观模式)/","excerpt":"","text":"本文为大家讲解的是php设计模式 中的Facade(外观模式)示例代码，感兴趣的同学参考下。 为子系统中的一组接口提供一个一致的界面,定义一个高层接口,使得这一子系统更加的容易使用模式定义：外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。模式结构： 外观模式的就是让client客户端以一种简单的方式来调用比较复杂的系统，来完成一件事情。 Subsystem： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?phpclass car &#123; public function start() &#123; print_r(\"车子启动\"); &#125; public function check_stop() &#123; print_r(\"刹车检查正常\"); &#125; public function check_box() &#123; print_r(\"检查油箱正常\"); &#125; public function check_console() &#123; print_r(\"检查仪表盘是否异常\"); &#125;&#125;//facade模式class carfacade &#123; public function catgo(car $carref)&#123; $carref-&gt;check_stop(); $carref-&gt;check_box(); $carref-&gt;check_console(); $carref-&gt;start(); &#125;&#125;//客户端可以简单的去调用。$car = new car();$carObj = new carfacade();$carObj-&gt;catgo($car);/*** 外观模式 示例** 为子系统中的一组接口提供一个一致的界面,定义一个高层接口,使得这一子系统更加的容易使用*/class SubSytem1&#123; public function Method1() &#123; echo \"subsystem1 method1&lt;br/&gt;\"; &#125;&#125;class SubSytem2&#123; public function Method2() &#123; echo \"subsystem2 method2&lt;br/&gt;\"; &#125;&#125;class SubSytem3&#123; public function Method3() &#123; echo \"subsystem3 method3&lt;br/&gt;\"; &#125;&#125;class Facade&#123; private $_object1 = null; private $_object2 = null; private $_object3 = null; public function __construct() &#123; $this-&gt;_object1 = new SubSytem1(); $this-&gt;_object2 = new SubSytem2(); $this-&gt;_object3 = new SubSytem3(); &#125; public function MethodA() &#123; echo \"Facade MethodA&lt;br/&gt;\"; $this-&gt;_object1-&gt;Method1(); $this-&gt;_object2-&gt;Method2(); &#125; public function MethodB() &#123; echo \"Facade MethodB&lt;br/&gt;\"; $this-&gt;_object2-&gt;Method2(); $this-&gt;_object3-&gt;Method3(); &#125;&#125;// 实例化$objFacade = new Facade();$objFacade-&gt;MethodA();$objFacade-&gt;MethodB();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Factory(工厂模式)","slug":"设计模式-factory(工厂模式)","date":"2018-06-19T13:19:34.677Z","updated":"2018-06-19T13:20:36.911Z","comments":true,"path":"2018/06/19/设计模式-factory(工厂模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-factory(工厂模式)/","excerpt":"","text":"本文为大家提供的是php设计模式中的 Factory(工厂模式)示例代码，感兴趣的同学参考下。 定义一个用于创建对象的接口,让子类决定将哪一个类实例化,使用一个类的实例化延迟到其子类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?php /** * 工厂方法模式 * * 定义一个用于创建对象的接口,让子类决定将哪一个类实例化,使用一个类的实例化延迟到其子类 */ /* class DBFactory &#123; public static function create($type) &#123; swtich($type) &#123; case \"Mysql\": return new MysqlDB(); break; case \"Postgre\": return new PostgreDB(); break; case \"Mssql\": return new MssqlDB(); break; &#125; &#125; &#125; */ class DBFactory &#123; public static function create($type) &#123; $class = $type.\"DB\"; return new $class; &#125; &#125; interface DB &#123; public function connect(); public function exec(); &#125; class MysqlDB implements DB &#123; public function __construct() &#123; echo \"mysql db&lt;br/&gt;\"; &#125; public function connect() &#123; &#125; public function exec() &#123; &#125; &#125; class PostgreDB implements DB &#123; public function __construct() &#123; echo \"Postgre db&lt;br/&gt;\"; &#125; public function connect() &#123; &#125; public function exec() &#123; &#125; &#125; class MssqlDB implements DB &#123; public function __construct() &#123; echo \"mssql db&lt;br/&gt;\"; &#125; public function connect() &#123; &#125; public function exec() &#123; &#125; &#125; $oMysql = DBFactory::create(\"Mysql\"); $oPostgre = DBFactory::create(\"Postgre\"); $oMssql = DBFactory::create(\"Mssql\");","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Interpreter(解释器模式)","slug":"设计模式-interpreter(解释器模式)","date":"2018-06-19T13:16:51.079Z","updated":"2018-06-19T13:18:25.591Z","comments":true,"path":"2018/06/19/设计模式-interpreter(解释器模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-interpreter(解释器模式)/","excerpt":"","text":"本文为大家讲解的是php设计模式 中的Interpreter(解释器模式)示例代码，感兴趣的同学参考下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php /** * 解释器 示例 * * @create_date: 2010-01-04 */ class Expression &#123; function interpreter($str) &#123; return $str; &#125; &#125; class ExpressionNum extends Expression &#123; function interpreter($str) &#123; switch($str) &#123; case \"0\": return \"零\"; case \"1\": return \"一\"; case \"2\": return \"二\"; case \"3\": return \"三\"; case \"4\": return \"四\"; case \"5\": return \"五\"; case \"6\": return \"六\"; case \"7\": return \"七\"; case \"8\": return \"八\"; case \"9\": return \"九\"; &#125; &#125; &#125;class ExpressionCharater extends Expression &#123; function interpreter($str) &#123; return strtoupper($str); &#125; &#125; class Interpreter &#123; function execute($string) &#123; $expression = null; for($i = 0;$i&lt;strlen($string);$i++) &#123; $temp = $string[$i]; switch(true) &#123; case is_numeric($temp): $expression = new ExpressionNum(); break; default: $expression = new ExpressionCharater(); &#125; echo $expression-&gt;interpreter($temp); &#125; &#125; &#125; $obj = new Interpreter(); $obj-&gt;execute(\"12345abc\");","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式 Strategy(策略模式)","slug":"设计模式-strategy(策略模式)","date":"2018-06-19T13:12:30.548Z","updated":"2018-06-19T13:15:08.791Z","comments":true,"path":"2018/06/19/设计模式-strategy(策略模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-strategy(策略模式)/","excerpt":"","text":"本文为大家提供的是php设计模式中的 Strategy(策略模式)示例代码，感兴趣的同学参考下。 定义一系列算法,把它们一个个封装起来,并且使它们可相互替换,使用得算法的变化可独立于使用它的客户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?php /** * 策略模式(Strategy.php) * * 定义一系列算法,把它们一个个封装起来,并且使它们可相互替换,使用得算法的变化可独立于使用它的客户 * */ // ---以下是一系列算法的封闭---- interface CacheTable &#123; public function get($key); public function set($key,$value); public function del($key); &#125; // 不使用缓存 class NoCache implements CacheTable &#123; public function __construct()&#123; echo \"Use NoCache&lt;br/&gt;\"; &#125; public function get($key) &#123; return false; &#125; public function set($key,$value) &#123; return true; &#125; public function del($key) &#123; return false; &#125; &#125; // 文件缓存 class FileCache implements CacheTable &#123; public function __construct() &#123; echo \"Use FileCache&lt;br/&gt;\"; // 文件缓存构造函数 &#125; public function get($key) &#123; // 文件缓存的get方法实现 &#125; public function set($key,$value) &#123; // 文件缓存的set方法实现 &#125; public function del($key) &#123; // 文件缓存的del方法实现 &#125; &#125; // TTServer class TTCache implements CacheTable &#123; public function __construct() &#123; echo \"Use TTCache&lt;br/&gt;\"; // TTServer缓存构造函数 &#125; public function get($key) &#123; // TTServer缓存的get方法实现 &#125; public function set($key,$value) &#123; // TTServer缓存的set方法实现 &#125; public function del($key) &#123; // TTServer缓存的del方法实现 &#125; &#125; // -- 以下是使用不用缓存的策略 ------ class Model &#123; private $_cache; public function __construct() &#123; $this-&gt;_cache = new NoCache(); &#125; public function setCache($cache) &#123; $this-&gt;_cache = $cache; &#125; &#125; class UserModel extends Model &#123; &#125; class PorductModel extends Model &#123; public function __construct() &#123; $this-&gt;_cache = new TTCache(); &#125; &#125; // -- 实例一下 --- $mdlUser = new UserModel(); $mdlProduct = new PorductModel(); $mdlProduct-&gt;setCache(new FileCache()); // 改变缓存策略","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Observer(观察者模式)","slug":"设计模式-observer(观察者模式)","date":"2018-06-19T13:10:23.076Z","updated":"2018-06-19T13:12:13.393Z","comments":true,"path":"2018/06/19/设计模式-observer(观察者模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-observer(观察者模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式 中的Observer(观察者模式)，感兴趣的同学参考下。 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新 能够便利地创建查看目标对象状态的对象,并且提供与核心对象非耦合的指定功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?php /** * 观察者模式 * * 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新 * 能够便利地创建查看目标对象状态的对象,并且提供与核心对象非耦合的指定功能 * 插件系统 */ class Observerable &#123; private $_observers = array(); public function registerObserver($observer) &#123; $this-&gt;_observers[] = $observer; &#125; public function removeObserver($observer) &#123; $key = array_search($observer,$this-&gt;_observers); if(!($key === false)) &#123; unset($this-&gt;_observers[$key]); &#125; &#125; public function notifyObservers() &#123; foreach($this-&gt;_observers as $observer) &#123; if($observer instanceof Observer) $observer-&gt;update($this); &#125; &#125; &#125; interface Observer &#123; public function update($observer); &#125; interface DisplayElement &#123; public function display(); &#125; // -- 实例类定义 class NewsObserverable extends Observerable &#123; private $_sports_news; public function setSportsNews($data) &#123; $this-&gt;_sports_news = $data; $this-&gt;notifyObservers(); &#125; public function getSportsNews() &#123; return $this-&gt;_sports_news; &#125; private $_local_news; public function setLocalNews($data) &#123; $this-&gt;_local_news = $data; $this-&gt;notifyObservers(); &#125; public function getLocalNews() &#123; return $this-&gt;_local_news; &#125; &#125; class SportsNews implements Observer,DisplayElement &#123; private $_data = null; public function update($observer) &#123; if($this-&gt;_data != $observer-&gt;getSportsNews()) &#123; $this-&gt;_data = $observer-&gt;getSportsNews(); $this-&gt;display(); &#125; &#125; public function display() &#123; echo $this-&gt;_data.date(\"Y-m-d H:i:s\").\"&lt;br/&gt;\"; &#125; &#125; class LocalNews implements Observer,DisplayElement &#123; private $_data = null; public function update($observer) &#123; if($this-&gt;_data != $observer-&gt;getLocalNews()) &#123; $this-&gt;_data = $observer-&gt;getLocalNews(); $this-&gt;display(); &#125; &#125; public function display() &#123; echo $this-&gt;_data.date(\"Y-m-d H:i:s\").\"&lt;br/&gt;\"; &#125; &#125; // -- 实例化 --- $objObserver = new NewsObserverable(); $local = new LocalNews(); $sports = new SportsNews(); $objObserver-&gt;registerObserver($local); $objObserver-&gt;registerObserver($sports); $objObserver-&gt;setSportsNews(\"sports news 1 \"); $objObserver-&gt;setLocalNews(\"local news 1 \"); $objObserver-&gt;removeObserver($sports); $objObserver-&gt;setLocalNews(\"local news 2 \"); $objObserver-&gt;setSportsNews(\"sports news 2 \"); $objObserver-&gt;removeObserver($local); $objObserver-&gt;setLocalNews(\"local news 3 \");","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Singleton(单例模式)","slug":"设计模式-singleton(单例模式)","date":"2018-06-19T13:06:16.336Z","updated":"2018-06-19T13:07:37.382Z","comments":true,"path":"2018/06/19/设计模式-singleton(单例模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-singleton(单例模式)/","excerpt":"","text":"本文为大家提供的是php设计模式 中的Singleton(单例模式)示例代码，感兴趣的同学参考下。 保证一个类仅有一个实例,并提供一个访问它的全局访问点 123456789101112131415161718192021222324252627282930313233343536&lt;?php /** * 单例模式 * * 保证一个类仅有一个实例,并提供一个访问它的全局访问点 * */ class Singleton &#123; static private $_instance = null; private function __construct() &#123; &#125; static public function getInstance() &#123; if(is_null(self::$_instance)) &#123; self::$_instance = new Singleton(); &#125; return self::$_instance; &#125; public function display() &#123; echo \"it is a singlton class function\"; &#125; &#125; // $obj = new Singleton(); // 声明不能成功 $obj = Singleton::getInstance(); var_dump($obj); $obj-&gt;display(); $obj1 = Singleton::getInstance(); var_dump(($obj === $obj1));","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Command(命令模式)","slug":"设计模式-command(命令模式)","date":"2018-06-19T13:01:00.581Z","updated":"2018-06-19T13:04:40.959Z","comments":true,"path":"2018/06/19/设计模式-command(命令模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-command(命令模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式 中的Command(命令模式)示例代码，感兴趣的同学参考下。 将一个请求封装为一个对象从而使你可用不同的请求对客户进行参数化,对请求排除或记录请求日志,以及支持可取消的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?php /** * 命令模式 * * 将一个请求封装为一个对象从而使你可用不同的请求对客户进行参数化,对请求排除或记录请求日志,以及支持可取消的操作 */ interface Command &#123; public function execute(); &#125; class Invoker &#123; private $_command = array(); public function setCommand($command) &#123; $this-&gt;_command[] = $command; &#125; public function executeCommand() &#123; foreach($this-&gt;_command as $command) &#123; $command-&gt;execute(); &#125; &#125; public function removeCommand($command) &#123; $key = array_search($command, $this-&gt;_command); if($key !== false) &#123; unset($this-&gt;_command[$key]); &#125; &#125; &#125; class Receiver &#123; private $_name = null; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function action() &#123; echo $this-&gt;_name.\" action&lt;br/&gt;\"; &#125; public function action1() &#123; echo $this-&gt;_name.\" action1&lt;br/&gt;\"; &#125; &#125; class ConcreteCommand implements Command &#123; private $_receiver; public function __construct($receiver) &#123; $this-&gt;_receiver = $receiver; &#125; public function execute() &#123; $this-&gt;_receiver-&gt;action(); &#125; &#125; class ConcreteCommand1 implements Command &#123; private $_receiver; public function __construct($receiver) &#123; $this-&gt;_receiver = $receiver; &#125; public function execute() &#123; $this-&gt;_receiver-&gt;action1(); &#125; &#125; class ConcreteCommand2 implements Command &#123; private $_receiver; public function __construct($receiver) &#123; $this-&gt;_receiver = $receiver; &#125; public function execute() &#123; $this-&gt;_receiver-&gt;action(); $this-&gt;_receiver-&gt;action1(); &#125; &#125; $objRecevier = new Receiver(\"No.1\"); $objRecevier1 = new Receiver(\"No.2\"); $objRecevier2 = new Receiver(\"No.3\"); $objCommand = new ConcreteCommand($objRecevier); $objCommand1 = new ConcreteCommand1($objRecevier); $objCommand2 = new ConcreteCommand($objRecevier1); $objCommand3 = new ConcreteCommand1($objRecevier1); $objCommand4 = new ConcreteCommand2($objRecevier2); // 使用 Recevier的两个方法 $objInvoker = new Invoker(); $objInvoker-&gt;setCommand($objCommand); $objInvoker-&gt;setCommand($objCommand1); $objInvoker-&gt;executeCommand(); $objInvoker-&gt;removeCommand($objCommand1); $objInvoker-&gt;executeCommand(); $objInvoker-&gt;setCommand($objCommand2); $objInvoker-&gt;setCommand($objCommand3); $objInvoker-&gt;setCommand($objCommand4); $objInvoker-&gt;executeCommand();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Template(模板模式)","slug":"设计模式-template(模板模式)","date":"2018-06-19T12:56:50.050Z","updated":"2018-06-19T12:59:43.093Z","comments":true,"path":"2018/06/19/设计模式-template(模板模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-template(模板模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式中的 Template (模板模式)示例代码，感兴趣的同学参考下。 定义一个操作中的算法骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构可以定义该算法的某些特定步骤继承关系由于自身的缺陷，被专家们扣上了“罪恶”的帽子。“使用委派关系代替继承关系”，“尽量使用接口实现而不是抽象类继承”等等专家警告，让我们这些菜鸟对继承“另眼相看”。其实，继承还是有很多自身的优点所在。只是被大家滥用的似乎缺点更加明显了。合理的利用继承关系，还是能对你的系统设计起到很好的作用的。而模板方法模式就是其中的一个使用范例。 GOF给模板方法（Template Method）模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。这里的算法的结构，可以理解为你根据需求设计出来的业务流程。特定的步骤就是指那些可能在内容上存在变数的环节。 可以看出来，模板方法模式也是为了巧妙解决变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。这一点，在下面的举例中可以很明显的看出来。 先看一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php /** * 模板模式 * * 定义一个操作中的算法骨架,而将一些步骤延迟到子类中,使得子类可以不改变一个算法的结构可以定义该算法的某些特定步骤 * */ abstract class TemplateBase &#123; public function Method1() &#123; echo \"abstract Method1&lt;br/&gt;\"; &#125; public function Method2() &#123; echo \"abstract Method2&lt;br/&gt;\"; &#125; public function Method3() &#123; echo \"abstract Method3&lt;br/&gt;\"; &#125; public function doSomeThing() &#123; $this-&gt;Method1(); $this-&gt;Method2(); $this-&gt;Method3(); &#125; &#125; class TemplateObject extends TemplateBase &#123; &#125; class TemplateObject1 extends TemplateBase &#123; public function Method3() &#123; echo \"TemplateObject1 Method3&lt;br/&gt;\"; &#125; &#125; class TemplateObject2 extends TemplateBase &#123; public function Method2() &#123; echo \"TemplateObject2 Method2&lt;br/&gt;\"; &#125; &#125; // 实例化 $objTemplate = new TemplateObject(); $objTemplate1 = new TemplateObject1(); $objTemplate2 = new TemplateObject2(); $objTemplate-&gt;doSomeThing(); $objTemplate1-&gt;doSomeThing(); $objTemplate2-&gt;doSomeThing(); AbstractClass（抽象类）：定义了一到多个的抽象方法，以供具体的子类来实现它们；而且还要实现一个模板方法，来定义一个算法的骨架。该模板方法不仅调用前面的抽象方法，也可以调用其他的操作，只要能完成自身的使命。 ConcreteClass（具体类）：实现父类中的抽象方法以完成算法中与特定子类相关的步骤。 根据上面对定义的分析，以及例子的说明，可以看出模板方法适用于以下情况： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。控制子类扩展。模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。比如上面runBare（）方法就只在runTest前面适用setUp方法。如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做：一是在API中不体现出你的模板方法；二、将你的模板方法置为final就可以了。可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。这样你在实现子类的时候，根本不需要对业务流程有太多的了解。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Proxy (代理模式)","slug":"设计模式-proxy (代理模式)","date":"2018-06-19T12:51:37.998Z","updated":"2018-06-19T12:55:05.521Z","comments":true,"path":"2018/06/19/设计模式-proxy (代理模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-proxy (代理模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式 中的Proxy (代理模式)示例代码，感兴趣的同学参考学习下。 为其他对象提供一个代理以控制这个对象的访问代理，指的就是一个角色代表另一个角色采取行动，就象生活中，一个红酒厂商，是不会直接把红酒零售客户的，都是通过代理来完成他的销售业务。而客户，也不用为了喝红酒而到处找工厂，他只要找到厂商在当地的代理就行了，具体红酒工厂在那里，客户不用关心，代理会帮他处理。 代理模式，就是给某一对象提供代理对象，并由代理对象控制具体对象的引用。 代理模式涉及的角色： 抽象主题角色，声明了代理主题和真实主题的公共接口，使任何需要真实主题的地方都能用代理主题代替。代理主题角色，含有真实主题的引用，从而可以在任何时候操作真实主题，代理主题功过提供和真实主题相同的接口，使它可以随时代替真实主题。代理主题通过持有真实主题的引用，不但可以控制真实主题的创建或删除，可以在真实主题被调用前进行拦截，或在调用后进行某些操作。真实代理对象，定义了代理角色所代表的具体对象。参考一下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php /** * 代理模式 * * 为其他对象提供一个代理以控制这个对象的访问 * */ interface Proxy &#123; public function request(); public function display(); &#125; class RealSubject &#123; public function request() &#123; echo \"RealSubject request&lt;br/&gt;\"; &#125; public function display() &#123; echo \"RealSubject display&lt;br/&gt;\"; &#125; &#125; class ProxySubject &#123; private $_subject = null; public function __construct() &#123; $this-&gt;_subject = new RealSubject(); &#125; public function request() &#123; $this-&gt;_subject-&gt;request(); &#125; public function display() &#123; $this-&gt;_subject-&gt;display(); &#125; &#125; $objProxy = new ProxySubject(); $objProxy-&gt;request(); $objProxy-&gt;display(); 代理模式的工作方式：首先，因为代理主题和真实主题都实现了共同的接口，这使我们可以在不改变原来接口的情况下，只要用真实主题对象的地方，都可以用代理主题来代替。其次，代理主题在客户和真实主题之间起了一个中介作用，利用这个中介平台，我们可以在把客户请求传递给真实主题之前做一些必要的预处理。 还有一个很常见的代理模式的使用例子就是对大幅图片浏览的控制。在我们常见的网站上面浏览图文的信息时，不知道你有没有注意到，图片位置放置的是经过缩小的，当有人要仔细的查看这个图片时，可以通过点击图片来激活一个链接，在一个新的网页打开要看的图片 。这样对于提高浏览速度是很有好处的，因为不是每个人都要去看仔细图上的信息。这种情况就可以使用代理模式来全面实现。这里我将思路表述出来，至于实现由于工作原因，就不表述了，至于这种方式在B/S模式下的真实可行性，我没有确认过，只是凭空的想象。如果不是可行的方式，那这个例子可以放到一个C/S下来实现，这个是绝对没有问题的，而且在很多介绍设计模式的书和文章中使用。两种方式的实现有兴趣的可以来尝试一下：） 我们在浏览器中访问网页时是调用的不是真实的装载图片的方法，而是在代理对象中的方法，在这个对象中，先使用一个线程向浏览器装载了一个缩小版的图片，而在后台使用另一个线程来调用真实的装载大图片的方法将图片加载到本地，当你要浏览这个图片的时候，将其在新的网页中显示出来。当然如果在你想浏览的时候图片尚未加载成功，可以再启动一个线程来显示提示信息，直到加载成功。 这样代理模式的功能就在上面体现的淋漓尽致——通过代理来将真实图片的加载放到后台来操作，使其不影响前台的浏览。 代理模式能够协调调用者和被调用者，能够在一定程度上降低系统的耦合度。不过一定要记住前面讲的使用代理模式的条件，不然的话使用了代理模式不但不会有好的效果，说不定还会出问题的。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-Composite(组合模式)","slug":"设计模式-composite(组合模式)","date":"2018-06-19T12:46:55.491Z","updated":"2018-06-19T12:49:18.271Z","comments":true,"path":"2018/06/19/设计模式-composite(组合模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-composite(组合模式)/","excerpt":"","text":"本文为大家提供的是php设计模式 中的Composite (组合模式)代码示例，感兴趣的同学参考学习下。 将对象组合成树形结构以表示”部分-整体”的层次结构,使得客户对单个对象和复合对象的使用具有一致性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?php /** * 组合模式 * * 将对象组合成树形结构以表示\"部分-整体\"的层次结构,使得客户对单个对象和复合对象的使用具有一致性 */ abstract class MenuComponent &#123; public function add($component)&#123;&#125; public function remove($component)&#123;&#125; public function getName()&#123;&#125; public function getUrl()&#123;&#125; public function display()&#123;&#125; &#125;class Menu extends MenuComponent &#123; private $_items = array(); private $_name = null; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function add($component) &#123; $this-&gt;_items[] = $component; &#125; public function remove($component) &#123; $key = array_search($component,$this-&gt;_items); if($key !== false) unset($this-&gt;_items[$key]); &#125; public function display() &#123; echo \"-- \".$this-&gt;_name.\" ---------&lt;br/&gt;\"; foreach($this-&gt;_items as $item) &#123; $item-&gt;display(); &#125; &#125; &#125;class Item extends MenuComponent &#123; private $_name = null; private $_url = null; public function __construct($name,$url) &#123; $this-&gt;_name = $name; $this-&gt;_url = $url; &#125; public function display() &#123; echo $this-&gt;_name.\"#\".$this-&gt;_url.\"&lt;br/&gt;\"; &#125; &#125;class Client &#123; private $_menu = null; public function __construct($menu) &#123; $this-&gt;_menu = $menu; &#125; public function setMenu($menu) &#123; $this-&gt;_menu = $menu; &#125; public function displayMenu() &#123; $this-&gt;_menu-&gt;display(); &#125; &#125; // 实例一下 // 创建menu $subMenu1 = new Menu(\"sub menu1\"); $subMenu2 = new Menu(\"sub menu2\"); $subMenu3 = new Menu(\"sub menu3\"); $item1 = new Item(\"163\",\"www.163.com\"); $item2 = new Item(\"sina\",\"www.sina.com\"); $subMenu1-&gt;add($item1); $subMenu1-&gt;add($item2); $item3 = new Item(\"baidu\",\"www.baidu.com\"); $item4 = new Item(\"google\",\"www.google.com\"); $subMenu2-&gt;add($item3); $subMenu2-&gt;add($item4); $allMenu = new Menu(\"All Menu\"); $allMenu-&gt;add($subMenu1); $allMenu-&gt;add($subMenu2); $allMenu-&gt;add($subMenu3); $objClient = new Client($allMenu); $objClient-&gt;displayMenu(); $objClient-&gt;setMenu($subMenu2); $objClient-&gt;displayMenu();","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"php设计模式-State(状态模式)","slug":"设计模式-state(状态模式)","date":"2018-06-19T12:30:26.948Z","updated":"2018-06-19T12:55:18.358Z","comments":true,"path":"2018/06/19/设计模式-state(状态模式)/","link":"","permalink":"http://blog.wddog.cn/2018/06/19/设计模式-state(状态模式)/","excerpt":"","text":"本文为大家介绍的是php设计模式 中的State (状态模式)示例代码，感兴趣的同学参考学习下。 允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它所属的类状态state模式是GOF23种模式中的一种，和命令模式一样，也是一种行为模式。状态模式和命令模式相当像，一样是“接口—实现类”这种模式的应用，是面向接口编程原则的体现。 状态模式属于对象创建型模式，其意图是允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了他的类。比较常见的例子是在一个表示网络连接的类TCPConnection，一个TCPConnection对象的状态处于若干不同的状态之一:连接已经建立(Established),正在监听，连接已经关闭(closed)。当一个TCPConnection对象收到其他对象的请求时，他根据自身的状态作出不同的反应。 例如：一个Open请求的结果依赖于该连接已关闭还是连接已建立状态。State模式描述了TCPConnection如何在每一种状态下表现出不同的行为。这一种模式的关键思想是引入了一个称为TCPState的抽象类表示网络的连接状态，TCPState类为各种表示不同的操作状态的字类声明了一个公共接口。TCPState的子类实现与特定的状态相关的行为。例如，TCPEstablished和TCPClosed类分别实现了特定于TCPConnection的连接已建立状态和连接已关闭状态的行为。 举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。 先看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?php/** * 状态模式 * * 允许一个对象在其内部状态改变时改变它的行为,对象看起来似乎修改了它所属的类 * */ /* 接口 定义所有状态该有的行为 */interface State &#123; public function handle($state); public function display(); &#125;class Context &#123; private $_state = null; public function __construct($state) &#123; $this-&gt;setState($state); &#125; public function setState($state) &#123; $this-&gt;_state = $state; &#125; public function request() &#123; $this-&gt;_state-&gt;display(); $this-&gt;_state-&gt;handle($this); &#125; &#125;class StateA implements State &#123; public function handle($context) &#123; $context-&gt;setState(new StateB()); &#125; public function display() &#123; echo \"state A&lt;br/&gt;\"; &#125; &#125; class StateB implements State &#123; public function handle($context) &#123; $context-&gt;setState(new StateC()); &#125; public function display() &#123; echo \"state B&lt;br/&gt;\"; &#125; &#125; class StateC implements State &#123; public function handle($context) &#123; $context-&gt;setState(new StateA()); &#125; public function display() &#123; echo \"state C&lt;br/&gt;\"; &#125; &#125; // 实例化一下 $objContext = new Context(new StateB()); $objContext-&gt;request(); $objContext-&gt;request(); $objContext-&gt;request(); $objContext-&gt;request(); $objContext-&gt;request(); 状态模式的理解，关键有2点：1. 通常命令模式的接口中只有一个方法。 而状态模式的接口中有1个或者多个方法。而且，状态模式的实现类的方法，一般返回值；或者是改变实 例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于 消除if…else等条件选择语句。 2. 主要的用途是，作为实例变量，是一个对象引用。命令模式的主要的使用方式是参数回调模式。命令接口作为方法的参数传递进来。然后，在方 法体内回调该接口。而状态模式的主要使用方法，是作为实例变量，通过set属性方法，或者构造器把状态接口的具体实现类的实例传递进来。因此 ，可以这样比较命令模式和状态模式的异同。 State模式和command模式都是十分常用，粒度比较小的模式，是很多更大型模式的一部分。基本上，state模式和command模式是十分相似的。只要开发者心中对单例和多例有一个清醒的认识，即使不把它们分为两种模式也没事。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/categories/Design-Patterns/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://blog.wddog.cn/tags/Design-Patterns/"}]},{"title":"服务器性能优化","slug":"服务器性能优化","date":"2018-06-11T15:25:20.814Z","updated":"2018-06-11T15:39:44.025Z","comments":true,"path":"2018/06/11/服务器性能优化/","link":"","permalink":"http://blog.wddog.cn/2018/06/11/服务器性能优化/","excerpt":"","text":"访问速度优化1. 页面静态化 --&gt; 定时任务 定时抓取， 生成 静态化 html 文件 提供给用户访问 优化单机性能 –&gt; 页面加载速度1. nginx 减少页面大小 启用 gzip 压缩 -&gt;服务器运算开销加大 配置如下： gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 6; geip_types text/plain application/javascript text/css application/xml; 2. 减少资源请求数量，合并和压缩 css ,js 等 -&gt; minify php 写的 重点是合并 minify：把 css 和 js 压缩和消减 去掉空格回车符等等，以及把多个 css js 文件整合到一个文件 3. 设置浏览器缓存 利用 CDN 加速 Nginx 配置文件缓存： location ~.*\\.(js|css|jpg|jpeg|gif|png)$ { # 指定缓存文件类型 expires 7d; # 设置浏览器过期时间 } 提高接口速度 -&gt; js 获取 cookie 判断是否登录1. 接口静态化： 后面的请求，当秒杀商品已经抢完， 其后的抢购毫无意义 快速总终止的逻辑放到前面 增加冗余的定制化数据，保证程序更快速 索引，数据规模， redis 缓存 2. 代码优化：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.wddog.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.wddog.cn/tags/Linux/"}]},{"title":"源码安装php7+swoole扩展","slug":"源码安装php7+swoole扩展","date":"2018-04-05T11:14:40.917Z","updated":"2018-04-05T12:14:20.498Z","comments":true,"path":"2018/04/05/源码安装php7+swoole扩展/","link":"","permalink":"http://blog.wddog.cn/2018/04/05/源码安装php7+swoole扩展/","excerpt":"","text":"下面我们就来说一说 php7 源码安装的故事， 了解过后还是简单的 首先我们从 PHP 官网(php.net)下载最新的源码包 考虑到有些大佬懒得找我就直接给你把地址弄在下面了 1http://am1.php.net/get/php-7.2.4.tar.gz/from/this/mirror 下载后就是解压了 12345tar -xzvf php-7.2.4.tar.gz // 解压cd php-7.2.4.tar.gz // 进入文件夹./configure --help // 查看帮助信息./configure --prefix=/applocation/php // 开始配置 --prefix=/applocation/php 你把软件安装在这个位置make &amp;&amp; make install 上面一顿操作基本就把 php7 装完了，是不是很简单， 没成功也没事，这边开始给你添坑了 1234567891011121314151617181920212223yum install libxml2-devel// libxml2-devel 是开发库，包含编译使用 libxml2 所需要的头文件、静态库和一些相关工具。从源码安装的会包含这些的。许多 Linux 发行版会进行拆包，把开发用的部分单独拆出去，因为很多人都用不到的。// 安装 gcc yum install gcc // ok// 安装 m4 wget http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.gztar -zvxf m4-1.4.9.tar.gzcd m4-1.4.9/./configure &amp;&amp; make &amp;&amp; make install// 安装 autoconfwget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gztar -zvxf autoconf-2.62.tar.gzcd autoconf-2.62/./configure &amp;&amp; make &amp;&amp; make install 好了！ 基本工作做完了，这边教你这么 配置 一波环境变量 让你的 php 在那个文件夹都能有用 1234vi ~/.bash_profile// 在后面添加 alias php=/applocation/php/bin/php // 有没有很熟悉 对了， 这就是前面的 安装路径source ~/.bash_profile // 这句话应该能猜出来什么意思吧 接下来就介绍一波添加 swoole 扩展了放心 依然简单 1234567891011121314151617// 首先老样子我们先下载一波源码 // swoole https://www.swoole.com/ 官网我这么就不教这么下载了 复制下面代码即可yum install git git clone https://gitee.com/swoole/swoole.git// 下载完成后 进入 swoole 目录cd swoole// 是不是觉得 ./configure 的时候到了 no 你压根找不到这个文件 哈哈 继续看// 执行 phpize 生成 ./configure 文件 phpize 在哪？ 就在你安装 php 位置的 bin 目录下 找到它// 我的安装位置是 /applocation/php /applocation/php/bin/phpize // 执行后生成 ./configure 文件./configure --with-php-config=/applocation/php/bin/php-config // 你总得告诉人家 php 在哪吧make &amp;&amp; make install // ok 最后 提一句 12345php.ini 文件 你上 你下载的 源码包里面找到 其中 php.ini-developmentcp php.ini-development php.inimv php.ini /applocation/php/lib // 移动到 lib 文件下// 你可以 php -i | grep php.ini 以上就是源码安装的全部流程了， 安装不上也别找我了，反正我终于写完了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.wddog.cn/tags/Linux/"}]},{"title":"腾讯云centos7 搭建 FTP","slug":"腾讯云centos7 搭建 FTP","date":"2018-03-19T06:18:40.705Z","updated":"2018-03-19T06:47:18.437Z","comments":true,"path":"2018/03/19/腾讯云centos7 搭建 FTP/","link":"","permalink":"http://blog.wddog.cn/2018/03/19/腾讯云centos7 搭建 FTP/","excerpt":"","text":"下面开始介绍 FTP 的搭建过程，异常简单 使用 yum 安装 vsftpd123yum install vsftpd // 这样就安装好了 服务service vsftpd start // 启动 ftp 服务 修改配置文件(现在配置文件的修改很简单)1234567891011121314151617vim /etc/vsftpd/vsftpd.conf// 找到 anonymous_enable=YES (可输入 /anonymous 搜索定位)// 修改为 anonymous_enable=NO 不允许匿名登录// 找到 去掉前面的 # (这三个一般都在一起)# chroot_local_user=YES# chroot_list_enable=YES# chroot_list_file=/etc/vsftpd/chroot_list // 这里面需放入创建的 ftp 用户名里面存在的用户才能登录// 最后 保存文件shift+: 输入 wq 保存退出 创建用户 并 重启 ftp1234567891011121314151617181920212223242526// 以下操作需要 root 权限cd / 切换到根目录mkdir ftp // 创建 ftp 用户的操作目录chmod -R 777 ftp // 设置权限为全部// 创建用户 目录为 /ftp 设置为 ftp 用户 -s /sbin/nologin 不可登录服务器 用户名 testuseradd -d /ftp -g ftp -s /sbin/nologin test// 为用户设置密码passwd test 输入一次密码确认密码vim /etc/vsftpd/chroot_list // 打开用户列表文件按 i 输入刚才创建的 用户 test 没增加一个用户都得在此文件添加用户名 并重启 vsftpd 服务 重启 ftp service vsftpd restart 到了这里就打开的你的登录软件 开始登录吧 输入你刚才的用户名 test 密码 选择 FTP 21端口 以上就是 FTP 搭建的全部流程, 其实还是很简单的， 大家记得安全组(这里不懂就自行百度了O(∩_∩)O哈哈~)","categories":[{"name":"centos","slug":"centos","permalink":"http://blog.wddog.cn/categories/centos/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.wddog.cn/tags/Linux/"},{"name":"腾讯云","slug":"腾讯云","permalink":"http://blog.wddog.cn/tags/腾讯云/"},{"name":"FTP","slug":"FTP","permalink":"http://blog.wddog.cn/tags/FTP/"}]},{"title":"阿里云ECS centos7.3 搭建 lamp 环境","slug":"阿里云ECS centos 7.3 搭建 lamp 环境","date":"2018-03-16T08:21:29.456Z","updated":"2018-03-16T08:39:34.056Z","comments":true,"path":"2018/03/16/阿里云ECS centos 7.3 搭建 lamp 环境/","link":"","permalink":"http://blog.wddog.cn/2018/03/16/阿里云ECS centos 7.3 搭建 lamp 环境/","excerpt":"","text":"一开始 搭建 lamp 环境还是挺让人捉急，一旦那部分错了，只能选择重装，今天我就给大家介绍一种比较简单的安装方式，亲测有效(Apache2.4 + Mysql5.7 + PHP5.6) LAMP安装有顺序：先安装Apache或Mysql，最后安装PHP1.安装Apache12345678yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql设置开机启动apachesystemctl enable httpd.service启动apachesystemctl start httpd.serviceApache 安装成功，虚拟主机等配置下面再说。 2.安装Mysql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647安装之前先删除以前版本，以免安装不成功。查看mysql的rpm包rpm -qa | gerp mysql查到之后就删除yum remove 文件名（可以一次多个名字，以空格分隔）例如：yum remove -y mysql mysql mysql-server mysql-libs compat-mysql51查看多余文件没删干净find / -name mysql 删除多余文件rm -rf 文件名例如：rm -rf /etc/my.cnf开始安装rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpmyum install -y mysql-server设置开机启动Mysqlsystemctl enable mysqld.service开启服务systemctl start mysqld.service查看Mysql5.7默认密码grep &apos;temporary password&apos; /var/log/mysqld.log登陆Mysql，输入用户名root，复制粘贴密码mysql -uroot -p修改密码(mysql5.7的密码设置规则：大写字母、小写字母、数字、特殊字符加起来)SET PASSWORD = PASSWORD(&apos;Abc123!&apos;);查看数据库show databases;Mysql配置安装成功。 配置远程连接数据库( 详细配置 )12345678910111213141516创建用户GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;a123456!&apos; WITH GRANT OPTION; （第一个root表示用户名，%表示所有的电脑都可以连接，也可以设置某个ip地址运行连接，第二个 a123456! 表示密码）。命令立即执行生效flush privileges;查看用户SELECT DISTINCT CONCAT(&apos;User: &apos;&apos;&apos;,user,&apos;&apos;&apos;@&apos;&apos;&apos;,host,&apos;&apos;&apos;;&apos;) AS query FROM mysql.user;配置成功exit;退出 3、安装PHP12345678910111213141516171819202122232425262728291.删除以前的php版本（跟上面删除mysql的命令是一样的）先查看rpm -qa | grep php 再删除yum remove 文件名2. 配置yum源事先确认yum源的链接是不是有效的。yum install epel-releaserpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm3. 确认安装的php版本yum list --enablerepo=remi --enablerepo=remi-php56 | grep php4. 安装php5.6yum install --enablerepo=remi --enablerepo=remi-php56 php php-opcache php-pecl-apcu php-devel php-mbstring php-mcrypt php-mysqlnd php-phpunit-PHPUnit php-pecl-xdebug php-pecl-xhprof php-pdo php-pear php-fpm php-cli php-xml php-bcmath php-process php-gd php-commonphp-opcache及php-pecl-apcu会有效的提高php执行速度。5. 确认php版本php -v安装成功 5、最后配置Apache123456789101112131415161718192021用ftp工具下载/etc/httpd/conf/httpd.conf到windows,用文本编辑工具打开1.# LoadModule foo_module modules/mod_foo.so //这句前面的#号不要去掉，否则apache重启动不了LoadModule rewrite_module modules/mod_rewrite.so 如果有mod_rewrite.so这句，就把这句前面的#号去掉；如果没有mod_rewrite.so这句，就在mod_foo.so这句后面加上这句；反正就是开启mod_rewrite.so这个服务2.把AllowOverride None改成AllowOverride All3.配置虚拟主机，把下面这段加在/etc/httpd/conf/httpd.conf最后面，注意去掉注释&lt;VirtualHost *:80&gt;ServerAdmin suibian@sina.com //随便哪个邮箱DocumentRoot &quot;/var/www/html/laravel5.2/public&quot; //项目的访问路径ServerName www.aliyun.com //域名，绑定这台服务器的IPDirectoryIndex index.php index.html index.htm //访问网站时默认打开的文件ErrorLog &quot;logs/www.aliyun.com-error_log&quot; //日志CustomLog &quot;logs/www.aliyun.com-access_log&quot; common //日志&lt;/VirtualHost&gt; 6、重启Apache1systemctl restart httpd.service ps: 搭建 vsftpd 的方法我会在后面的文章中放出来(放心比这更简单)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.wddog.cn/categories/Linux/"}],"tags":[{"name":"centos7.3","slug":"centos7-3","permalink":"http://blog.wddog.cn/tags/centos7-3/"},{"name":"阿里云","slug":"阿里云","permalink":"http://blog.wddog.cn/tags/阿里云/"},{"name":"lamp","slug":"lamp","permalink":"http://blog.wddog.cn/tags/lamp/"}]},{"title":"关于网站多语言的一些实现方案(复制文章)","slug":"网站多语言研究探讨方案","date":"2018-03-09T16:02:53.959Z","updated":"2018-03-09T16:14:44.522Z","comments":true,"path":"2018/03/10/网站多语言研究探讨方案/","link":"","permalink":"http://blog.wddog.cn/2018/03/10/网站多语言研究探讨方案/","excerpt":"","text":"由于全球化的推进，多语言网站开始流行起来，未来的网站可能至少会有双语（中文/英语），对于多语言网站，我给出如下几种方案，希望想要制作多语言网站的人能够从中找到适合自己的。 出处: http://www.ytmp.net/forum.php?mod=viewthread&amp;tid=245&amp;extra=page%3D3 方案一：引入谷歌翻译器 此方案博主早先试过了，翻译成英语还行，其他基本看不懂了，要求不是很高的可以试试，还是挺不错了 谷歌翻译推出了一个在线翻译网站的神器，你可以通过接入谷歌翻译器来实现多语言网站。但是，目前谷歌被墙，所以此方案可能暂时无法实现，未来谷歌回归中国，还是可以使用此方案的。推荐指数：❤❤❤ 方案二：动态设置模板即网站使用模板可以动态设置，制作网站的时候，同时制作多个语言版本的模板，栏目和文章都定制（一个中文，一个英文）。原系统模板只能后台设置使用的模板，也就是写入配置文件中，我个人觉得不要修改配置文件为好，所以为了安全，将模板读取修改为读取数据库的数据，这样就可以安全多了。缺点：工作量比较大。推荐指数：❤❤❤❤ 方案三：制作多语言插件（参考wordpress本地化设计）这个难度有点大，不过应该是最理想的实现多语言网站的方法。自定义一个翻译方法，比如：_lang()此方法用于翻译文字，将数据传入_lang方法里面，此方法读取语言包，如果有对应语言包，那么将翻译成对应的语言，如果没有则返回字符串。语言包制作：键值对的形式，首选读取网站所有的文字数据，然后对应进行人工翻译，可制作多种语言包，进行相应设定，_lang方法将读取语言包里对应的翻译语言，这样就实现多语言版本。（说起来比较抽象，下面给出个例子） 123456789101112模板页面中：&#123;fun _lang('世界你好 &lt;--&gt; hello world！')&#125;//注：doyo中使用_lang方法Functions.php中：public function _lang($word)&#123; //制作一个表，读取表中设定的语言字段，此字段可以前台传入数据进行修改 $lang=DB('language')-&gt;select(xxxxx);//读取当前模板使用的语言 $lanlist=require(xxx);//引入多语言包，键值对的文件，可以是return array($word=&gt;'bbb'); if($lanlist[$word])&#123; return $lanlist[$word]; &#125;else&#123; return $word; &#125;&#125; 语言包文件：language.phpreturn array(‘aa’=&gt;’xxx’,’bb’=&gt;’sada’….);//此为举例，语言包可以制作成其它的，看个人喜好。多语言包插件制作就介绍到这里，其中有许多简略部分，因为我也没有制作~推荐指数：❤❤❤ 以上，希望对各位有所帮助~","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"关于 PHP 无限极分类","slug":"PHP无限极分类","date":"2018-03-09T15:46:32.811Z","updated":"2018-03-09T15:53:00.667Z","comments":true,"path":"2018/03/09/PHP无限极分类/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/PHP无限极分类/","excerpt":"","text":"废话不多说直接放代码 —&gt; 反正不我写的 (勿喷！大佬代码，谁逼 ，直接打死) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 验证字符长度 * @param $str 字符串 * @param $min 最小 * @param $max 最大 * @return bool * @author 小黄牛 * @email 1731223728@163.com */function strLength($str,$min,$max)&#123; $length = strlen($str); if($length &gt;= $min &amp;&amp; $length &lt;= $max)&#123; return true; &#125;else&#123; return false; &#125;&#125;/** * 无限递归下拉选择框 * @param $data 数组 * @param $pid 父id * @param int $t 循环次数：作用缩进 * @param int $selected 选中的下标 * @return string * @author 小黄牛 * @email 1731223728@163.com * @date 2015-10-22 */function html_options($data=array(), $pid=0, $t=-1, $selected=0)&#123; $html_options = ''; $t++; $nbspstr = str_repeat('&amp;nbsp;', $t * 4); if ($data) &#123; foreach ($data as $k =&gt; $v) &#123; if($pid == $v['pid'])&#123; // 判断是否是最后一个下拉选项卡 $symbol_str = (count($data) == ($k+1)) ? '┗' : '┣'; // 判断是否选中 $selected_str = ($selected == $v['id']) ? ' selected=\"selected\"' : ''; // 下拉选择框数据 $html_options .= '&lt;option value=\"' . $v['id'] . '\" '.$selected_str.'&gt;' . $nbspstr . $symbol_str . $v['name'] . '&lt;/option&gt;'; // 无限循环查找子集 $html_options .= html_options($data, $v['id'], $t, $selected); &#125; &#125; &#125; return $html_options;&#125;/** * 无限分类 * @param $array * @param int $pid * @return array */function tree($array, $pid = 0)&#123; $arr = array(); $tem = array(); foreach ($array as $v) &#123; if ($v['pid'] == $pid) &#123; $tem = tree($array, $v['id']); //判断是否存在子数组 $tem &amp;&amp; $v['child'] = $tem; $arr[] = $v; &#125; &#125; return $arr;&#125;/** * 二维数组递归 * @param array $arr * @return array * @author 小黄牛 * @email 1731223728@163.com */function category($arr = array())&#123; $info = array(); if(count($arr) &gt; 0)&#123; foreach($arr as $k =&gt; $vo)&#123; if($vo['pid'] == 0 )&#123; foreach($arr as $v)&#123; if($v['pid'] == $vo['id'])&#123; $vo['children'][] = $v; &#125; &#125; $info[] = $vo; &#125; &#125; &#125; return $info;&#125;/** * 无限递归 * @param $data 数组 * @param $pid 父id * @param int $t 循环次数：作用缩进 * @return 数组 * @author 小黄牛 * @email 1731223728@163.com * @date 2015-10-22 */function html_options($data=array(), $pid=0, $t=-1, &amp;$arr)&#123; $html_options = ''; $t++; $nbspstr = str_repeat('&amp;nbsp;', $t * 4); if ($data) &#123; foreach ($data as $k =&gt; $v) &#123; if($pid == $v['st_pid'])&#123; // 判断是否是最后一个下拉选项卡 $symbol_str = (count($data) == ($k+1)) ? '└' : '├'; // 数据 $v['st_name'] = $nbspstr . $symbol_str . $v['st_name']; $arr[] = $v; // 无限循环查找子集 $this-&gt;html_options($data, $v['st_id'], $t, $arr); &#125; &#125; &#125; return $arr;&#125; 结尾语： 弱弱问一句， 你们发现哪些 是我写的了吗， 对不起，我还是个孩子","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"据 PHPExcel 封装的一个快捷函数,解决输出 Excel 代码的重复","slug":"phpexcel 快捷函数","date":"2018-03-09T15:35:55.920Z","updated":"2018-03-09T15:45:13.841Z","comments":true,"path":"2018/03/09/phpexcel 快捷函数/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/phpexcel 快捷函数/","excerpt":"","text":"关于 phpexcel 数据写入的一层封装 使数据写入更加简便使用方法如下 tp5 中 把函数放入公共函数 引入 phpexcel 类即可使用极其简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 此函数依赖 PHPExcel 使用方法可参考 admin\\controller\\CustomerController.php-&gt;outputExcel * 快捷方法 添加excel 数据 * @param PHPExcel $phpexcelObj 对象 * @param Array $title 表格 列字段名 必需 * @param Array $data 表格数据 必须按照 标题位置存放 必需 * @return Object $objSheet # 数据对象 */function exceloutput( $phpexcelObj,$title=array(), $data=array())&#123; if( !$phpexcelObj &amp;&amp; !empty($title) &amp;&amp; !empty($data) )&#123; return false; &#125; # 加载扩展库 extend/phpexcel/PHPExcel.php $phpexcel = $phpexcelObj; // 实例化等同与新建一个excel 文件 $objSheet = $phpexcel-&gt;getActiveSheet(); // 获取当前活动的 sheet 工作区 $objSheet-&gt;setTitle('demo'); // 给当前活动的 sheet 设置名称 $column_names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S','T', 'U', 'V', 'W', 'X', 'Y', 'Z']; $curC = -1; # 列表位置 A-Z AA AB ... BA BB... $strColumn = ''; # 要拼接的字符 通过 $curC for( $i=0; $i&lt;count($title); $i++ )&#123; if( $i&lt;count($column_names) )&#123; # 当列小于 数组长度时 $strColumn = $column_names[$i].\"1\"; # 列 A1 B1 C1 ... &#125; else &#123; if((($i+1)%count($column_names)) == 1)&#123; # 当前 使用列 每循环一次列就 选择 下一个作为 开头 AA AB AC... BA BB BC... $curC++; &#125; $strColumn = $column_names[$curC].$column_names[$i%count($column_names)].\"1\"; # 大于 26 个字母后的列 拼接 &#125; $objSheet-&gt;setcellValue($strColumn,$title[$i]); # 设置 标题 &#125; $j = 2; # 当前行 # 写入内容 foreach( $data as $val )&#123; $curC = -1; # 列表位置 A-Z AA AB ... BA BB... $strColumn = ''; # 要拼接的字符 通过 $curC for( $i=0; $i&lt;count($title); $i++ )&#123; if( $i&lt;count($column_names) )&#123; # 当列小于 数组长度时 $strColumn = $column_names[$i].$j; # 列 &#125; else &#123; if((($i+1)%count($column_names)) == 1)&#123; # 当前 使用列 每循环一次列就 选择 下一个作为 开头 AA AB AC... BA BB BC... $curC++; &#125; $strColumn = $column_names[$curC].$column_names[$i%count($column_names)].$j; # 大于 26 个字母后的列 拼接 &#125; $objSheet-&gt;setcellValue($strColumn,$val[$title[$i]]); # 设置 标题 &#125; $j++; # 移到下一行 &#125; return $phpexcelObj; &#125; 在控制器方法中调用以下代码 数据 根据具体业务查询 1234567891011121314151617# 查询所有列名$columns = Db::query(\"select column_name from information_schema.columns where table_name='\".config('database.prefix').\"customer'\");$data = Db::table(config('database.prefix').\"customer\")-&gt;select(); # 查询所有数据$title = array();foreach( $columns as $column )&#123; # 列名格式化成数组 $title[] = $column['column_name'];&#125;// dump($title);// dump($data);Loader::import('phpexcel.PHPExcel'); # 加载扩展库 extend/phpexcel/PHPExcel.php$PHPExcel = new \\PHPExcel();$phpexcelObj = exceloutput( $PHPExcel,$title, $data); # 使用 函数添加数据 返回工作区数据对象$PHPWriter = \\PHPExcel_IOFactory::createWriter($phpexcelObj,\"Excel2007\"); # 写入数据header('Content-Disposition: attachment;filename=\"表单数据.xlsx\"'); # 告知浏览器输出文件 文件吗 为 表单数据header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); # 输出格式$PHPWriter-&gt;save(\"php://output\"); //表示在$path路径下面生成demo.xlsx文件 结尾语： 因技术有限，东西是很龊的，但是，多少还是能用的 —&gt; 想批评我，没门","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"Redis 随笔","slug":"Redis","date":"2018-03-09T15:22:43.288Z","updated":"2018-03-09T15:34:39.305Z","comments":true,"path":"2018/03/09/Redis/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/Redis/","excerpt":"","text":"选择目录启动命令： redis-server.exe redis.windows.conf redis-cli.exe -h 127.0.0.1 -p 6379 redis 可用来存储字符串，哈希结构，链表，集合，常用来提供数据结构服务 redis 和 memcached 的一些独特之处 redis 可以用来做存储，而 memcached 只是 用来做缓存 主要因为 redis 具有持久化的功能 存储的数据有结构， 对于 memcached 来说，存储的数据，只有一种类型–字符串，而 redis 则可以存储字符串，链表，哈希，集合，有序集合 +++++++++++++++++++++++++++通用类型操作+++++++++++++++++++++++++++++++++++++++++set 设置值 格式： set key valueget 获取值 get key查询， keys keys s keys key 还可使用 ？ * [] 找出键值 Randomkey 返回随机的一个 keyExists key 判断 key 是否存在type key 判断 key 类型del key 删除一个 keyrename key new key给 key 改名renamenx key new key 使用这个命令改成一个已存在的名字时将不会进行 改名 redis 向我们提供了 16 个库 使用 select 0~15move key 1 移动这个键值对到 1 号数据库redis 默认是无生命周期的 -1 不存的也返回 -1 永久有效ttl key 查询生命周期 返回过期的秒数 已过期， 永久有效的都返回-1 2.8 后 不存在的返回-2expire key 以秒数来设置生命周期 pexpire以毫秒为单位 ptti 一毫秒为单位返回生命周期persist key 把他变为永久有效 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ============================数据格式的操作======================================String： 字符串: 在设置时，直接指定过期时间：set key value ex 秒数 px 毫秒 [nx] 【xx】注：ex,px 不能同时写，否则以后面有效期为准nx 当key 不存在时执行xx 存在时执行一次设置多个值：mset multi set格式： mset a 1 b 2 c 3 mget key1 key2 一次获取多个键值 setrange key # 要替换的值 append key value 往值后面添加getrange key start stop // 获取值得一小部分 getset 获取旧值并设置新值 用在秒杀资格incr key 将值加一decr key 将值减一 incrby key 5.. 可设置每次增加多少decrby key 5.. incrbyfloat key 0.5 浮点数增加 在 位 上做操作A ASCLL 65 0100 0001a ASCLL 97 0110 0001setbit:格式： setbit key 偏移量 1|0 offset(偏移量) 512MB 值为 2^32-1 flushdb // 清楚所有数据 link（list） : 链表操作： 单链表 ， 双向链表， 循环链表key: 都是一个lpush : 格式 lpush key value 加入到链表头部（l|left 左边）rpush ：格式 rpush key value 加入到链表尾部（r|reft 右边） rpop : 格式：rpop key 从链表尾部弹出（删除）一个值lpop : 格式：lpop key 从链表首（左）部弹出（删除）一个值 lrange: (linkrange) //范围取值，查看链表值 格式： lrange key 0 2 (从0开始取出第一个) lrem : lrem key count value lrem name (2) xiaoming 删除几个 整数从左开始 -数从右边开始 ltrim: ltrim key 2 5 截取一段 在获取一次，截取在重新赋值给keylindex: lindex key # 去除第几个，下标从 0 开始llen： llen key 获取长度 linsert : linsert key after|before search value沿着链表找到某个值，在前|后 插入值 rpoplpush : rpoplpush key1 key2右边弹出，左边插入一个 一个链表右边的移到另一个链表的左边 brpop,blpop: brpop blpop key timeout(时间为秒) 等待 pop (使用场景ajax长轮询时) （国外大型网站使用） 位图法统计活跃用户： 1亿用户，活跃用户非活跃用户，如何记录用户的登陆信息，如何查询活跃用户，比如一周内登陆三次的 使用redis高效解决： 使用 位 1亿个位登陆的置于 1 反之 0 假设只有 7 个用户 uid 分别位 1,2,3,4,5,6,7 周一 0 1 0 1 0 0 0 1 //首位为0 代表正数 这里记录一天的登陆的情况 周二 0 1 1 1 0 0 1 1 周三 0 1 1 1 0 1 0 1 周四 0 1 0 1 1 0 0 1 统计： 连续登录的就做 and 操作 10000001 利用 redis 的 setbit 操作 星期一： setbit mon 100000000 0 setbit mon 3 1 谁登陆把谁置为1 星期二： set thur 1000000000 0 set thur 2 1 bitop: and or xor not (逻辑并，逻辑或，逻辑异或，逻辑非); 格式为： bitop and destkey key [key …] 将结果保存在 destkey 中 做一个 and 运算得到1 就代表连续登陆一周 优点： 节约空间，一亿人每天的登陆情况，用一亿 bit 约 1200Wbyte 约 10M 的字符就能表示 计算快 ================= set（集合） 结构： 特点： 无序性，｛1,2｝=={2,1} 唯一性 独一无二 确定性 sadd key value1 value2往集合内添加元素 srem key value1 value2删除集合中value1 value2的元素，返回值，除去不存在的值后，返回删除的个数 srandmember key返回集合key 中的任意一个元素 spop key返回并且删除集合中随意的一个元素 smembers key返回集合中的所有元素 sismember key value判断 value 是否在 key 集合中， 存在为 1 反之 0 smove source dest value把source 集合中的 value 删除 并 添加到 dest 集合中 scard key返回集合中元素的个数 sinter key1 key2 key3求出 key1 key2 key3 中的交集，并返回 sinterstore dest key1 key2 key3求出 key1 key2 key3 中的交集，并返回给dest sunion key1 key2…求出 key1 key2 key..的并集并返回 sdiff key1 key 2 key ..求出他们的差集 有序集合： order set： score(序) 声明时定义 score 确定其序 zadd score1 value1 score2 value2添加元素 zrem key value1 value2删除元素zremrangebyscore key min max按照 score 来删除元素 删除 min 与 max 之间的zremrangbyrank key start end按排名删除元素删除名次在 start 与 end 之间的 zrank key member查看 member 的排名（升序）zrevrank key member查看 member 的排名（降序） zrange key start stop查询排序后第start 名到第stop名 的zrange key 1 3 withscores 另外在取出score zrangebyscore key score1 score2取出 score1 和 score2 之间的值 zrangebyscore key score1 score2 limit 1 2 跳过第一个在取出两个 zcard key返回元素个数 zcount key min max返回min max 之间的元素个数 (zinsterstore) destination numkeys key1[key2…] zunionstore(并集)weights wight [weight..] // 权重 我的一块顶你五块aggregate sum|min|max求key1 key2的交集， key1 key2的权重分别是weight1 weight2聚合方法使用：sum min max聚合结果保存在dest 集合中 哈希： hash （相当于php的关联数组合） hset : hset key field value设置(关联数组)field valuename lisiage 20height 174 hmset:hmset key field value name lisi一次设置多个 hgetall:hgetall key获取键中所有元素 hget:hget key name一次获取一个 hmget：hmget key name field 一次获取多个 hdel：hdel key name删除一个 hlen:hlen key有几个域（键） hexists：hexists key namename是否存在 hincrby:hincby key field value增长一个hincrbyfloat:hkeys： 事务及锁：mysql :启用事务： start transaction rollback 回滚 redis 事务： 不支持回滚，命令执行了就执行了 开启： multi (多) 之后的命令都放到待执行队列中exec： 运行提交输入错误的命令后 队列中的命令就都不能执行，如果命令正确，类型不正确，将跳过那条语句，执行其他的discard 清空执行队列中命令 监视： 悲观锁操作时上锁，只有我能操作 乐观锁 注意有没有更改值，有就不执行 (秒杀)watch key 监视着这个值unwatch 取消所有监视的 key (适合做在线聊天，消息推送）群聊广告消息发布，订阅：声明一个频道订阅新闻频道发布新闻内容 publish news “today is xxx” 创建一个频道news 发布subscribe news 收听频道news psubscribe 可以通配 news* 的全部监听 （以模式一次匹配多个频道） pubsub 2.8.0 列出当前活动的频道 发布端 收听端口 查看当前活动频道，发布者，监听者 +++++++++++++++++++++++=============redis两种持久化： rdb aof 可同时存在rdb快照持久化： 把数据存储于断电后不会丢失的设备中，通常是硬盘常见的持久化方式： 主从：通过从服务器保存和持久化，mongodb的replication sets配置日志：操作生成相关日志，并通过日志来回复数据couchdb对于数据内容，不修改,只追加，则文件本身就是日志，不会丢失数据 rdb工作原理：每隔 N 分钟或 N 次写操作后，从内存 dump 数据形成 rdb 文件，压缩，放在备份目录 参数配置（时间|次数、压缩、目录） rdb 快照相关参数： save 900 1 ！刷新快照到硬盘中，必须满足两者要求才会触发，即 900 秒后至少 1 个关键字发生变化save 300 10 ! 必须是 300 秒后 至少 10 个关键字发生变化save 60 10000 ! 必须是 60 秒后，至少 10000 个关键字发生变化stop-writes-on-bgsave-error yes ! 后台存储错误停止写rdbcompression yes ! 使用 LZF 压缩 rdb 文件rdnchecksum yes ! 存储和加载 rdb 文件时校验dbfilename dump.rdb ! 设置 rdb 文件名dir ./ ! 设置工作目录，rdb 文件会写入该目录 redis-benchmark 测试性能 （crud）-n 10000 (执行 10000 条命令)-hlep -h 帮助 aof:setappend -》 redis 主进程 -》 后台日志程序 -》 aof 文件 配置文件： appendonly no|yes 是否打开 aof 日志功能appendfsync always 每一个命令，都立即同步到 aof 安全速度慢appendfsync everysec 折中方法，每秒写一次appendfsync no 写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到 aof 同步效率低，速度快 no-appendfsync-no-rewrite yes 正在导出 rdb 快照时的过程中，要不要停止 aofauto-aof-rewrite-percentage 100 aof 文件大小比起上次重写时的大小，增长 100% 时重写 auto-aof-rewrite-min-size 64mb aof 文件，至少超过64MB时，重写 注： 在dump rdb 过程中，aof 停止同步，会丢失吗？不会，所有操作的缓存在队列里，dump 完成后，统一操作 注：如果 rdb 文件 aof 文件都存在，优先用谁来恢复数据aof 注：两者是否可以同时用可以，而且推荐这么用 注：恢复时 rdb aof 那个恢复时间快rdb 因为其是数据的映射，直接载入到内存，而 aof 是命令，需要逐条运行 当一个值 100 次 incr 将产生 100 次记录， 下次恢复时从1次开始， 如何把它 直接到 100 次在某个瞬间逆化成命令 incr age 100次 set age 100注：aof 重写？aof 重写是把内存中的数据逆化成命令，写入 aof 日志里，以解决 aof 日志过大问题*（标识，真实文件中不存在）的配置文件 到了这个大小获取最终值，整个 aof 大小将减小bgrewriteaof 命令重写 +++++++++++++++++=========================== redis 服务器端命令： time 服务器时间dbsize 当前数据库 key 的数量 ++++++++++++================================= redis 主从配置： 服务器集群集群的作用： 主从备份，防止主机宕机 读写分离，分担 master 的任务 任务分离，如从服分别分担备份工作与计算工作 两种方式： 环形，线形线形的好处 ，直接切换到 slave1 不需要在链接 slave2 12345678910 sync[自动] &lt;---------------- dump 出rdb master ----------------&gt; slave 缓冲的aof ----------------&gt; replicationFeedSlaves ----------------&gt; : slave 连接到master 然后自动告知 同步（sync）一下，回送 数据映射的rdb 文件 ，在传rdb文件时，同时缓存的命令在 aof 中, 再同步到 slave一个进程保持联系 集群配置： 关闭 rdb 快照 (把备份工作交给 salve) 可以开启 aof salve 设置： 声明 salve-of 配置密码[如果master有密码] [某一个]salve 打开 rdb 快照功能 配置是否只读 [salve-read-only] 复制配置文件修改配置文件： redis6380.conf redis6381.conf 修改其中的 pidfile /..为redis63.pid port: 为63设置slave : 打开slaveof 添加ip 和端口 ：本地的话使用 127.0.0.1是否只读 salve-read-only no|yes只其中一个开启 rdb 快照，其余关闭 启动从服务器 redis-server redis6380.conf redis-cli -p 6380 连接6380端口添加密码： requirepass 密码进入后使用 auth 密码设置密码后，从服务器必须有密码才能连接到主服务器masterauth 密码 主从复制缺陷： 每次slave断开后(无论是主动的还是网络故障)再连接 master都要 master 全部 dump 出来 rdb 再 aof 即同步的过程都要重新执行一遍所以记住，多来 slave 不要一下全部启动，否则 master 可能 IO剧增 运维常用命令： time: 返回两个值 一个命令执行时的时间戳，一个执行完毕后过去多少微秒dbsize : 当前库中 有多少 keybgrewriteaof: 后台进程重写 aofbgsave: 后台保存 rdb 快照save: 保存 rdb 快照lastsave: 上次保存时间 返回时间戳slaveof: 设为 slave 服务器flushall: 清空所有 DBflushdb: 清空当前 DBshutdown: save|nosave 断开连接，关闭服务器slowlog: 显示慢查询info: 显示服务器信息config get: 获取配置信息config set: 设置配置信息monitor: 打开控制台sync: 主从同步client list: 客户端列表client kill 关闭某个客户端client setname 为某个客户端设置名字client getname 获取客户端名字 慢日志： slowlog 多慢才叫慢由slowlog-log-slower-than 10000 来指定，单位微妙 服务器存储多少条慢查询的记录： slowlog-max-len 128 来做限制slowlog get N 获取慢日志 =================================== aof 恢复 与 rdb 服务器迁移 当不小心 flushdb、 flushall时，立即shudowm nosave(这条任务不要写到aof文件中),防止其他访问，导致aof重写，到aof文件中删除这条命令redis-check-dump 检查rdb文件是否存在错误（重）在 redis 进程运行时，rdb 处于打开状态，这时因为占据同样的句柄，rdb 不可用 sentinel 运维监控（官方自带的） 手动操作： config get 选项 config set 选项 运行时：更改 master-slave修改一台 slave 为 master 1) 命令该服务，不做其他 redis 的 slave命令：slaveof no one 2) 修改 salve-read-only 为 no命令：config set salve-read-only no其他的 slave 再指向 这个 new master A 1）命令该服务为 new master A 的 slave命令: slaveofIP port 注：slaveof 127.0.0.1 6379 sentinel做的就是以上操作，不断与 master 通信， 当master 不回应，就切换其中一个为master 监控配置： sentinel monitor def_master 127.0.0.1 6379 2(结合三十秒，监控到2次连不上才是失效)sentinel auth-pass def-master 012_345^678-90 master 要不要密码 ！master 被当前 sentinel 实例 认定为 失效的间隔时间！如果当前的 sentinel 与 master 直接的通讯中，在指定的时间内，没有响应或者响应错误代码，那么当前 sentinel 就认为master 失效，（SDOWN 主观失效） 默认为 30 秒sentinel down-after-millseconds def_master 30000 当前 sentinel 实例是否允许实施 failover (故障转移)no 表示当前 sentinel 为观察者(只参与投票，不参与实施 failover )全局中至少有一个yessentinel can-failover def_master yes 监控到失效 允不允许把slave 改为master 在多个sentinel监控时，只一个有权利修改为masterfailover notification-script mymaster /var/redis/notify.shparallel-syncs mymaster 1 同时几台连接到新的 master (如果瞬间全部连接，ＩＯ激增，容易GG) 配置文件： sentinel.conf （windows好像没有）redis-server sentinel.conf –sentinel 启动sentinel 进程 在 配置文件中，slave-priority 100 数字越小优先级最高 改完优先把优先级高的作为新的 master ++++++++++++++++++++++++++++++++++++ 实际开发技巧：key-value 与传统的 关系型数据库有何关联 如何 key 设计 书签系统： create table book( book_id int, title char(20))engine myisam charset utf8; redis 键值设置：1）把表名转换为key 前缀2）主键3）主键值4) 写要存储的列名set user:id:4:name 小明 无底洞效应:… 如何使用username 查询，只能冗余信息set user:username:lisi:userid 9 维护一个相互引用的数据通过 userid 查 name,mail ,age …不会导致很多冗余，只是 保存 id 世上安得双修法，不负如来不负卿。。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://blog.wddog.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.wddog.cn/tags/Redis/"}]},{"title":"php 生成唯一订单的 6 种方法","slug":"PHP生成唯一订单的 6 种方法","date":"2018-03-09T15:09:06.266Z","updated":"2018-03-09T15:16:57.112Z","comments":true,"path":"2018/03/09/PHP生成唯一订单的 6 种方法/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/PHP生成唯一订单的 6 种方法/","excerpt":"","text":"PHP生成唯一订单号其实是非常的简单了我们随便就可以整理多种生成方式了，这里小编整理了6种方式供各位参考。 做商城类项目经常需要生成唯一订单号，下面来个汇总！ 方法一:1return date('Ymd') . str_pad(mt_rand(1, 99999), 5, '0', STR_PAD_LEFT); 方法二:1234567891011121314151617/** * * uniqid - 官方是这样说的： * Gets a prefixed unique identifier based on the current time in microseconds. */ function build_order_no() &#123; return date('Ymd').&lt;a href=\"/tags.php/substr/\" target=\"_blank\"&gt;substr&lt;/a&gt;(implode(NULL, array_map('ord', str_split(substr(uniqid(), 7, 13), 1))), 0, 8); &#125; 用uniqid获取一个基于当前的微秒数生成的唯一不重复的字符串（但是他的前7位貌似很久才会发生变动，所以不用考虑可删除），取其第8到13位。但是这个字符串里面有英文字母，咋办？ 用ord获取他的ASCII码，所以就有了下一步：用str_split把这个字符串分割为数组，用array_map去操作（速度快点）。 然后返回的还是一个数组，KO，在用implode弄成字符串，但是字符长度不定，取前固定的几位，然后前面加上当前的年份和日期，这个方法生成的订单号，全世界不会有多少重复的。 当然，除非你把服务器时间往前调，但是调也不用怕，哥不相信他会在同一微秒内下两次订单，网络数据传输也要点时间的，即便你是在本地。 方法三:12345678910111213public function make_order($user_id) &#123; return mt_rand(10,99) . sprintf('%010d',time() - 946656000) . sprintf('%03d', (float) microtime() * 1000) . sprintf('%03d', (int) $user_id % 1000); &#125; 方法四: 我是比较喜欢这种方式的(O(∩_∩)O哈哈~)1234$yCode = array('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'); $orderSn = $yCode[intval(date('Y')) - 2011] . strtoupper(dechex(date('m'))) . date('d') . substr(time(), -5) . substr(microtime(), 2, 5) . sprintf('%02d', rand(0, 99 )); 方法五 生成24位唯一订单号码:123456789101112131415161718192021//生成24位唯一订单号码，格式：YYYY-MMDD-HHII-SS-NNNN,NNNN-CC，其中：YYYY=年份，MM=月份，DD=日期，HH=24格式小时，II=分，SS=秒，NNNNNNNN=随机数，CC=检查码 @date_default_timezone_set(\"PRC\"); while(true)&#123; //订购日期 $order_date = date('Y-m-d'); //订单号码主体（YYYYMMDDHHIISSNNNNNNNN） $order_id_main = date('YmdHis') . rand(10000000,99999999); //订单号码主体长度 $order_id_len = strlen($order_id_main); $order_id_sum = 0; for($i=0; $i&lt;$order_id_len; $i++)&#123; $order_id_sum += (int)(substr($order_id_main,$i,1)); &#125; //唯一订单号码（YYYYMMDDHHIISSNNNNNNNNCC） $order_id = $order_id_main . str_pad((100 - $order_id_sum % 100) % 100,2,'0',STR_PAD_LEFT); if($result = sqlite_query($db,\"SELECT * FROM orders WHERE order_id='$order_id'\"))&#123; if(sqlite_num_rows($result) == 0)&#123; break; &#125; &#125; 例子六:12345678910111213141516171819/** * 生成16位纯数字订单号 * 最大支持时间到 2056-12-31 23:59:59 * * @access public * @return string //phpfensi.com */ public static function getOrderSN() &#123; return (date('y') + date('m') + date('d')) . str_pad((time() - &lt;a href=\"/tags.php/strtotime/\" target=\"_blank\"&gt;strtotime&lt;/a&gt;(date('Y-m-d'))), 5, 0, STR_PAD_LEFT) . substr(microtime(), 2, 6) . sprintf('%03d', rand(0, 999)); &#125; 目前在用的,基本保证不重复了,能用到2056年,觉得应该够了,以后有需求再扩展.","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"Mysql 忘记密码解决与用户创建，授权详解","slug":"Mysql小技巧","date":"2018-03-09T10:54:48.450Z","updated":"2018-03-09T12:47:29.576Z","comments":true,"path":"2018/03/09/Mysql小技巧/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/Mysql小技巧/","excerpt":"","text":"当你忘记 Mysql 密码时，又能操作 服务器 (Linux) 时 就能很简单的重设密码，下面就和我一起学习吧！ 一、Mysql 绕过密码登录1. KILL掉系统里的MySQL进程；2. 用以下命令启动MySQL，以不检查权限的方式启动；1mysqld_safe --skip-grant-tables &amp; 3. 然后用空密码方式使用root用户登录 MySQL；1mysql -u root 4. 修改 root 用户密码123mysql&gt; update mysql.user set password=PASSWORD（&apos;123456&apos;） where User=root and host=&apos;localhost&apos;；mysql&gt; flush privileges； // 把配置写入内存 生效mysql&gt; quit 5. 重新启动MySQL，就可以使用新密码登录了。1mysql -u root -p123456 二、MySQL添加新用户、为用户创建数据库、为新用户分配权限登录MySQL12mysql -u root -p 添加新用户允许本地 IP 访问 localhost, 127.0.0.1 1create user &apos;test&apos;@&apos;localhost&apos; identified by &apos;123456&apos;; 允许外网 IP 访问1create user &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;; 刷新授权1flush privileges; 为用户创建数据库1create database test DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 为新用户分配权限授予用户通过外网IP对于该数据库的全部权限1grant all privileges on `testdb`.* to &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;; 授予用户在本地服务器对该数据库的全部权限1grant all privileges on `testdb`.* to &apos;test&apos;@&apos;localhost&apos; identified by &apos;123456&apos;; 刷新权限1flush privileges; 退出 root 重新登录1exit 用新帐号 test 重新登录，由于使用的是 % 任意IP连接，所以需要指定外部访问IP1mysql -u test -h 115.28.203.224 -p 在Ubuntu服务器下，MySQL默认是只允许本地登录，因此需要修改配置文件将地址绑定给注释掉： 123# Instead of skip-networking the default is now to listen only on # localhost which is more compatible and is not less secure. #bind-address = 127.0.0.1 #注释掉这一行就可以远程登录了 不然会报如下错误： ERROR 2003 (HY000): Can’t connect to MySQL server on ‘host’ (111)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wddog.cn/categories/Mysql/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"},{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wddog.cn/tags/Mysql/"}]},{"title":"又重新搭建了一个博客，此次使用 Hexo + Github 搭建","slug":"前言","date":"2018-03-05T10:42:08.835Z","updated":"2018-03-06T03:32:31.908Z","comments":true,"path":"2018/03/05/前言/","link":"","permalink":"http://blog.wddog.cn/2018/03/05/前言/","excerpt":"","text":"使用 Hexo 搭建个人博客还是很简单的，极其轻松，使用也简单，最好的是你甚至不需要 域名，也不需要服务器，在 Github上注册一个账号，你就能很快的搭建一个好看又好用的博客了，这对学生党而言就是福音了，毕竟穷(我也一脸穷苦相，妈耶！) 前言Hexo 的文章格式也极其简单，使用的 Markdown 标记语言,你只需要记住几个简单的标记，就能满足日常使用的。。。(不像 HTML 那一堆的标记，简直记得头大)接下来就告诉你一些 简单 Markdown 快 get 到自己的 Blog 吧 一、标题123456# 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题 效果如下：一级标题二级标题三级标题四级标题五级标题六级标题二、列表Markdown 支持有序列表和无序列表。 无序列表使用-、+和*作为列表标记：1234567891011- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示：1231. Red2. Green3. Blue 效果如下： Red Green Blue 三、引用引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 常见的引用写法： 12345678910111213141516171819&gt; 这是一段引用 //在`&gt;`后面有 1 个空格&gt; &gt; 这是引用的代码块形式 //在`&gt;`后面有 5 个空格&gt; &gt; 代码例子：&gt; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; #### 这是一个四级标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项 效果如下： 这是一段引用 //在&gt;后面有 1 个空格 这是引用的代码块形式 //在`&gt;`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 一级引用 二级引用 三级引用 这是一个四级标题 这是第一行列表项 这是第二行列表项 四、强调两个或-代表加粗，一个或-代表斜体，~~代表删除。 12345**加粗文本** 或者 __加粗文本__*斜体文本* 或者_斜体文本_~~删除文本~~ 效果如下：加粗文本 或者 加粗文本 斜体文本 或者斜体文本 删除文本 五、图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式： 123图片：![]() ![图片文本(可忽略)](图片地址)链接：[]() [链接文本](链接地址) 链接又分为行内式、参考式和 自动链接： 12345678910111213这是行内式链接：[ConnorLin&apos;s Blog](http://connorlin.github.io)。这是参考式链接：[ConnorLin&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。[url]: http://connorlin.github.io/ &quot;ConnorLin&apos;s Blog&quot;链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://connorlin.github.io&gt;这是图片：![][avatar][avatar]: https://connorlin.github.io/images/avatar.jpg 效果如下：这是行内式链接：ConnorLin’s Blog。 这是参考式链接：ConnorLin’s Blog，其中url为链接标记，可置于文中任意位置。 链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略) 这是自动链接：直接使用&lt;&gt;括起来http://connorlin.github.io 这是图片： 六、代码代码分为行内代码和代码块。 行内代码使用 代码 标识，可嵌入文字中 代码块使用4个空格或12 这里是代码123456代码语法高亮在 ```后面加上空格和语言名称即可``` 语言//注意语言前面有空格这里是代码 例如： 12345678910这是行内代码`onCreate(Bundle savedInstanceState)`的例子。这是代码块和语法高亮：``` java// 注意java前面有空格protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125; 效果如下：这是行内代码onCreate(Bundle savedInstanceState)的例子。 这是代码块和语法高亮： 1234if(true)&#123; echo \"我真是一个又帅又令人发情的 Boy\";&#125; 七、表格表格对齐格式 居左：:—- 居中：:—-:或—– 居右：—-: 例子： 123456|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333| 效果如下： 标题 标题 标题 居左测试文本 居中测试文本 居右测试文本 居左测试文本1 居中测试文本2 居右测试文本3 居左测试文本11 居中测试文本22 居右测试文本33 居左测试文本111 居中测试文本222 居右测试文本333 八、分割线在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。 12345***---___* * * 效果均为一条分割线： 九、换行在行尾添加两个空格加回车表示换行： 1这是一行后面加两个空格 换行 效果如下：这是一行后面加两个空格换行 十、脚注(注解)使用[^]来定义脚注： 123这是一个脚注的例子[^1][^1]: 这里是脚注 效果如下：这是一个脚注的例子[^1] 扩展：常用弥补Markdown的Html标签字体12&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt; 效果如下：字体及字体颜色和大小字体颜色 换行 1使用html标签`&lt;br/&gt;`&lt;br/&gt;换行 效果如下：使用html标签换行 文本对齐方式 123&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt; 效果如下：居左文本居中文本居右文本 下划线 1&lt;u&gt;下划线文本&lt;/u&gt; 效果如下：下划线文本 That’s all, Enjoy it!","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"http://blog.wddog.cn/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.wddog.cn/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://blog.wddog.cn/tags/Github/"}]}]}