{"meta":{"title":"帅气的狗头","subtitle":null,"description":"我们敲代码的不懂这些，，，","author":"xiaoxie","url":"http://blog.wddog.cn"},"pages":[{"title":"categories","date":"2018-03-06T03:49:36.000Z","updated":"2018-03-06T03:49:58.542Z","comments":false,"path":"categories/index.html","permalink":"http://blog.wddog.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-06T03:47:23.000Z","updated":"2018-03-06T03:48:26.655Z","comments":false,"path":"tags/index.html","permalink":"http://blog.wddog.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于 PHP 无限极分类","slug":"PHP无限极分类","date":"2018-03-09T15:46:32.811Z","updated":"2018-03-09T15:53:00.667Z","comments":true,"path":"2018/03/09/PHP无限极分类/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/PHP无限极分类/","excerpt":"","text":"废话不多说直接放代码 —&gt; 反正不我写的 (勿喷！大佬代码，谁逼 ，直接打死) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 验证字符长度 * @param $str 字符串 * @param $min 最小 * @param $max 最大 * @return bool * @author 小黄牛 * @email 1731223728@163.com */function strLength($str,$min,$max)&#123; $length = strlen($str); if($length &gt;= $min &amp;&amp; $length &lt;= $max)&#123; return true; &#125;else&#123; return false; &#125;&#125;/** * 无限递归下拉选择框 * @param $data 数组 * @param $pid 父id * @param int $t 循环次数：作用缩进 * @param int $selected 选中的下标 * @return string * @author 小黄牛 * @email 1731223728@163.com * @date 2015-10-22 */function html_options($data=array(), $pid=0, $t=-1, $selected=0)&#123; $html_options = ''; $t++; $nbspstr = str_repeat('&amp;nbsp;', $t * 4); if ($data) &#123; foreach ($data as $k =&gt; $v) &#123; if($pid == $v['pid'])&#123; // 判断是否是最后一个下拉选项卡 $symbol_str = (count($data) == ($k+1)) ? '┗' : '┣'; // 判断是否选中 $selected_str = ($selected == $v['id']) ? ' selected=\"selected\"' : ''; // 下拉选择框数据 $html_options .= '&lt;option value=\"' . $v['id'] . '\" '.$selected_str.'&gt;' . $nbspstr . $symbol_str . $v['name'] . '&lt;/option&gt;'; // 无限循环查找子集 $html_options .= html_options($data, $v['id'], $t, $selected); &#125; &#125; &#125; return $html_options;&#125;/** * 无限分类 * @param $array * @param int $pid * @return array */function tree($array, $pid = 0)&#123; $arr = array(); $tem = array(); foreach ($array as $v) &#123; if ($v['pid'] == $pid) &#123; $tem = tree($array, $v['id']); //判断是否存在子数组 $tem &amp;&amp; $v['child'] = $tem; $arr[] = $v; &#125; &#125; return $arr;&#125;/** * 二维数组递归 * @param array $arr * @return array * @author 小黄牛 * @email 1731223728@163.com */function category($arr = array())&#123; $info = array(); if(count($arr) &gt; 0)&#123; foreach($arr as $k =&gt; $vo)&#123; if($vo['pid'] == 0 )&#123; foreach($arr as $v)&#123; if($v['pid'] == $vo['id'])&#123; $vo['children'][] = $v; &#125; &#125; $info[] = $vo; &#125; &#125; &#125; return $info;&#125;/** * 无限递归 * @param $data 数组 * @param $pid 父id * @param int $t 循环次数：作用缩进 * @return 数组 * @author 小黄牛 * @email 1731223728@163.com * @date 2015-10-22 */function html_options($data=array(), $pid=0, $t=-1, &amp;$arr)&#123; $html_options = ''; $t++; $nbspstr = str_repeat('&amp;nbsp;', $t * 4); if ($data) &#123; foreach ($data as $k =&gt; $v) &#123; if($pid == $v['st_pid'])&#123; // 判断是否是最后一个下拉选项卡 $symbol_str = (count($data) == ($k+1)) ? '└' : '├'; // 数据 $v['st_name'] = $nbspstr . $symbol_str . $v['st_name']; $arr[] = $v; // 无限循环查找子集 $this-&gt;html_options($data, $v['st_id'], $t, $arr); &#125; &#125; &#125; return $arr;&#125; 结尾语： 弱弱问一句， 你们发现哪些 是我写的了吗， 对不起，我还是个孩子","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"据 PHPExcel 封装的一个快捷函数,解决输出 Excel 代码的重复","slug":"phpexcel 快捷函数","date":"2018-03-09T15:35:55.920Z","updated":"2018-03-09T15:45:13.841Z","comments":true,"path":"2018/03/09/phpexcel 快捷函数/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/phpexcel 快捷函数/","excerpt":"","text":"关于 phpexcel 数据写入的一层封装 使数据写入更加简便使用方法如下 tp5 中 把函数放入公共函数 引入 phpexcel 类即可使用极其简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 此函数依赖 PHPExcel 使用方法可参考 admin\\controller\\CustomerController.php-&gt;outputExcel * 快捷方法 添加excel 数据 * @param PHPExcel $phpexcelObj 对象 * @param Array $title 表格 列字段名 必需 * @param Array $data 表格数据 必须按照 标题位置存放 必需 * @return Object $objSheet # 数据对象 */function exceloutput( $phpexcelObj,$title=array(), $data=array())&#123; if( !$phpexcelObj &amp;&amp; !empty($title) &amp;&amp; !empty($data) )&#123; return false; &#125; # 加载扩展库 extend/phpexcel/PHPExcel.php $phpexcel = $phpexcelObj; // 实例化等同与新建一个excel 文件 $objSheet = $phpexcel-&gt;getActiveSheet(); // 获取当前活动的 sheet 工作区 $objSheet-&gt;setTitle('demo'); // 给当前活动的 sheet 设置名称 $column_names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S','T', 'U', 'V', 'W', 'X', 'Y', 'Z']; $curC = -1; # 列表位置 A-Z AA AB ... BA BB... $strColumn = ''; # 要拼接的字符 通过 $curC for( $i=0; $i&lt;count($title); $i++ )&#123; if( $i&lt;count($column_names) )&#123; # 当列小于 数组长度时 $strColumn = $column_names[$i].\"1\"; # 列 A1 B1 C1 ... &#125; else &#123; if((($i+1)%count($column_names)) == 1)&#123; # 当前 使用列 每循环一次列就 选择 下一个作为 开头 AA AB AC... BA BB BC... $curC++; &#125; $strColumn = $column_names[$curC].$column_names[$i%count($column_names)].\"1\"; # 大于 26 个字母后的列 拼接 &#125; $objSheet-&gt;setcellValue($strColumn,$title[$i]); # 设置 标题 &#125; $j = 2; # 当前行 # 写入内容 foreach( $data as $val )&#123; $curC = -1; # 列表位置 A-Z AA AB ... BA BB... $strColumn = ''; # 要拼接的字符 通过 $curC for( $i=0; $i&lt;count($title); $i++ )&#123; if( $i&lt;count($column_names) )&#123; # 当列小于 数组长度时 $strColumn = $column_names[$i].$j; # 列 &#125; else &#123; if((($i+1)%count($column_names)) == 1)&#123; # 当前 使用列 每循环一次列就 选择 下一个作为 开头 AA AB AC... BA BB BC... $curC++; &#125; $strColumn = $column_names[$curC].$column_names[$i%count($column_names)].$j; # 大于 26 个字母后的列 拼接 &#125; $objSheet-&gt;setcellValue($strColumn,$val[$title[$i]]); # 设置 标题 &#125; $j++; # 移到下一行 &#125; return $phpexcelObj; &#125; 在控制器方法中调用以下代码 数据 根据具体业务查询 1234567891011121314151617# 查询所有列名$columns = Db::query(\"select column_name from information_schema.columns where table_name='\".config('database.prefix').\"customer'\");$data = Db::table(config('database.prefix').\"customer\")-&gt;select(); # 查询所有数据$title = array();foreach( $columns as $column )&#123; # 列名格式化成数组 $title[] = $column['column_name'];&#125;// dump($title);// dump($data);Loader::import('phpexcel.PHPExcel'); # 加载扩展库 extend/phpexcel/PHPExcel.php$PHPExcel = new \\PHPExcel();$phpexcelObj = exceloutput( $PHPExcel,$title, $data); # 使用 函数添加数据 返回工作区数据对象$PHPWriter = \\PHPExcel_IOFactory::createWriter($phpexcelObj,\"Excel2007\"); # 写入数据header('Content-Disposition: attachment;filename=\"表单数据.xlsx\"'); # 告知浏览器输出文件 文件吗 为 表单数据header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); # 输出格式$PHPWriter-&gt;save(\"php://output\"); //表示在$path路径下面生成demo.xlsx文件 结尾语： 因技术有限，东西是很龊的，但是，多少还是能用的 —&gt; 想批评我，没门","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"Redis 随笔","slug":"Redis","date":"2018-03-09T15:22:43.288Z","updated":"2018-03-09T15:34:39.305Z","comments":true,"path":"2018/03/09/Redis/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/Redis/","excerpt":"","text":"选择目录启动命令： redis-server.exe redis.windows.conf redis-cli.exe -h 127.0.0.1 -p 6379 redis 可用来存储字符串，哈希结构，链表，集合，常用来提供数据结构服务 redis 和 memcached 的一些独特之处 redis 可以用来做存储，而 memcached 只是 用来做缓存 主要因为 redis 具有持久化的功能 存储的数据有结构， 对于 memcached 来说，存储的数据，只有一种类型–字符串，而 redis 则可以存储字符串，链表，哈希，集合，有序集合 +++++++++++++++++++++++++++通用类型操作+++++++++++++++++++++++++++++++++++++++++set 设置值 格式： set key valueget 获取值 get key查询， keys keys s keys key 还可使用 ？ * [] 找出键值 Randomkey 返回随机的一个 keyExists key 判断 key 是否存在type key 判断 key 类型del key 删除一个 keyrename key new key给 key 改名renamenx key new key 使用这个命令改成一个已存在的名字时将不会进行 改名 redis 向我们提供了 16 个库 使用 select 0~15move key 1 移动这个键值对到 1 号数据库redis 默认是无生命周期的 -1 不存的也返回 -1 永久有效ttl key 查询生命周期 返回过期的秒数 已过期， 永久有效的都返回-1 2.8 后 不存在的返回-2expire key 以秒数来设置生命周期 pexpire以毫秒为单位 ptti 一毫秒为单位返回生命周期persist key 把他变为永久有效 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ============================数据格式的操作======================================String： 字符串: 在设置时，直接指定过期时间：set key value ex 秒数 px 毫秒 [nx] 【xx】注：ex,px 不能同时写，否则以后面有效期为准nx 当key 不存在时执行xx 存在时执行一次设置多个值：mset multi set格式： mset a 1 b 2 c 3 mget key1 key2 一次获取多个键值 setrange key # 要替换的值 append key value 往值后面添加getrange key start stop // 获取值得一小部分 getset 获取旧值并设置新值 用在秒杀资格incr key 将值加一decr key 将值减一 incrby key 5.. 可设置每次增加多少decrby key 5.. incrbyfloat key 0.5 浮点数增加 在 位 上做操作A ASCLL 65 0100 0001a ASCLL 97 0110 0001setbit:格式： setbit key 偏移量 1|0 offset(偏移量) 512MB 值为 2^32-1 flushdb // 清楚所有数据 link（list） : 链表操作： 单链表 ， 双向链表， 循环链表key: 都是一个lpush : 格式 lpush key value 加入到链表头部（l|left 左边）rpush ：格式 rpush key value 加入到链表尾部（r|reft 右边） rpop : 格式：rpop key 从链表尾部弹出（删除）一个值lpop : 格式：lpop key 从链表首（左）部弹出（删除）一个值 lrange: (linkrange) //范围取值，查看链表值 格式： lrange key 0 2 (从0开始取出第一个) lrem : lrem key count value lrem name (2) xiaoming 删除几个 整数从左开始 -数从右边开始 ltrim: ltrim key 2 5 截取一段 在获取一次，截取在重新赋值给keylindex: lindex key # 去除第几个，下标从 0 开始llen： llen key 获取长度 linsert : linsert key after|before search value沿着链表找到某个值，在前|后 插入值 rpoplpush : rpoplpush key1 key2右边弹出，左边插入一个 一个链表右边的移到另一个链表的左边 brpop,blpop: brpop blpop key timeout(时间为秒) 等待 pop (使用场景ajax长轮询时) （国外大型网站使用） 位图法统计活跃用户： 1亿用户，活跃用户非活跃用户，如何记录用户的登陆信息，如何查询活跃用户，比如一周内登陆三次的 使用redis高效解决： 使用 位 1亿个位登陆的置于 1 反之 0 假设只有 7 个用户 uid 分别位 1,2,3,4,5,6,7 周一 0 1 0 1 0 0 0 1 //首位为0 代表正数 这里记录一天的登陆的情况 周二 0 1 1 1 0 0 1 1 周三 0 1 1 1 0 1 0 1 周四 0 1 0 1 1 0 0 1 统计： 连续登录的就做 and 操作 10000001 利用 redis 的 setbit 操作 星期一： setbit mon 100000000 0 setbit mon 3 1 谁登陆把谁置为1 星期二： set thur 1000000000 0 set thur 2 1 bitop: and or xor not (逻辑并，逻辑或，逻辑异或，逻辑非); 格式为： bitop and destkey key [key …] 将结果保存在 destkey 中 做一个 and 运算得到1 就代表连续登陆一周 优点： 节约空间，一亿人每天的登陆情况，用一亿 bit 约 1200Wbyte 约 10M 的字符就能表示 计算快 ================= set（集合） 结构： 特点： 无序性，｛1,2｝=={2,1} 唯一性 独一无二 确定性 sadd key value1 value2往集合内添加元素 srem key value1 value2删除集合中value1 value2的元素，返回值，除去不存在的值后，返回删除的个数 srandmember key返回集合key 中的任意一个元素 spop key返回并且删除集合中随意的一个元素 smembers key返回集合中的所有元素 sismember key value判断 value 是否在 key 集合中， 存在为 1 反之 0 smove source dest value把source 集合中的 value 删除 并 添加到 dest 集合中 scard key返回集合中元素的个数 sinter key1 key2 key3求出 key1 key2 key3 中的交集，并返回 sinterstore dest key1 key2 key3求出 key1 key2 key3 中的交集，并返回给dest sunion key1 key2…求出 key1 key2 key..的并集并返回 sdiff key1 key 2 key ..求出他们的差集 有序集合： order set： score(序) 声明时定义 score 确定其序 zadd score1 value1 score2 value2添加元素 zrem key value1 value2删除元素zremrangebyscore key min max按照 score 来删除元素 删除 min 与 max 之间的zremrangbyrank key start end按排名删除元素删除名次在 start 与 end 之间的 zrank key member查看 member 的排名（升序）zrevrank key member查看 member 的排名（降序） zrange key start stop查询排序后第start 名到第stop名 的zrange key 1 3 withscores 另外在取出score zrangebyscore key score1 score2取出 score1 和 score2 之间的值 zrangebyscore key score1 score2 limit 1 2 跳过第一个在取出两个 zcard key返回元素个数 zcount key min max返回min max 之间的元素个数 (zinsterstore) destination numkeys key1[key2…] zunionstore(并集)weights wight [weight..] // 权重 我的一块顶你五块aggregate sum|min|max求key1 key2的交集， key1 key2的权重分别是weight1 weight2聚合方法使用：sum min max聚合结果保存在dest 集合中 哈希： hash （相当于php的关联数组合） hset : hset key field value设置(关联数组)field valuename lisiage 20height 174 hmset:hmset key field value name lisi一次设置多个 hgetall:hgetall key获取键中所有元素 hget:hget key name一次获取一个 hmget：hmget key name field 一次获取多个 hdel：hdel key name删除一个 hlen:hlen key有几个域（键） hexists：hexists key namename是否存在 hincrby:hincby key field value增长一个hincrbyfloat:hkeys： 事务及锁：mysql :启用事务： start transaction rollback 回滚 redis 事务： 不支持回滚，命令执行了就执行了 开启： multi (多) 之后的命令都放到待执行队列中exec： 运行提交输入错误的命令后 队列中的命令就都不能执行，如果命令正确，类型不正确，将跳过那条语句，执行其他的discard 清空执行队列中命令 监视： 悲观锁操作时上锁，只有我能操作 乐观锁 注意有没有更改值，有就不执行 (秒杀)watch key 监视着这个值unwatch 取消所有监视的 key (适合做在线聊天，消息推送）群聊广告消息发布，订阅：声明一个频道订阅新闻频道发布新闻内容 publish news “today is xxx” 创建一个频道news 发布subscribe news 收听频道news psubscribe 可以通配 news* 的全部监听 （以模式一次匹配多个频道） pubsub 2.8.0 列出当前活动的频道 发布端 收听端口 查看当前活动频道，发布者，监听者 +++++++++++++++++++++++=============redis两种持久化： rdb aof 可同时存在rdb快照持久化： 把数据存储于断电后不会丢失的设备中，通常是硬盘常见的持久化方式： 主从：通过从服务器保存和持久化，mongodb的replication sets配置日志：操作生成相关日志，并通过日志来回复数据couchdb对于数据内容，不修改,只追加，则文件本身就是日志，不会丢失数据 rdb工作原理：每隔 N 分钟或 N 次写操作后，从内存 dump 数据形成 rdb 文件，压缩，放在备份目录 参数配置（时间|次数、压缩、目录） rdb 快照相关参数： save 900 1 ！刷新快照到硬盘中，必须满足两者要求才会触发，即 900 秒后至少 1 个关键字发生变化save 300 10 ! 必须是 300 秒后 至少 10 个关键字发生变化save 60 10000 ! 必须是 60 秒后，至少 10000 个关键字发生变化stop-writes-on-bgsave-error yes ! 后台存储错误停止写rdbcompression yes ! 使用 LZF 压缩 rdb 文件rdnchecksum yes ! 存储和加载 rdb 文件时校验dbfilename dump.rdb ! 设置 rdb 文件名dir ./ ! 设置工作目录，rdb 文件会写入该目录 redis-benchmark 测试性能 （crud）-n 10000 (执行 10000 条命令)-hlep -h 帮助 aof:setappend -》 redis 主进程 -》 后台日志程序 -》 aof 文件 配置文件： appendonly no|yes 是否打开 aof 日志功能appendfsync always 每一个命令，都立即同步到 aof 安全速度慢appendfsync everysec 折中方法，每秒写一次appendfsync no 写入工作交给操作系统，由操作系统判断缓冲区大小，统一写入到 aof 同步效率低，速度快 no-appendfsync-no-rewrite yes 正在导出 rdb 快照时的过程中，要不要停止 aofauto-aof-rewrite-percentage 100 aof 文件大小比起上次重写时的大小，增长 100% 时重写 auto-aof-rewrite-min-size 64mb aof 文件，至少超过64MB时，重写 注： 在dump rdb 过程中，aof 停止同步，会丢失吗？不会，所有操作的缓存在队列里，dump 完成后，统一操作 注：如果 rdb 文件 aof 文件都存在，优先用谁来恢复数据aof 注：两者是否可以同时用可以，而且推荐这么用 注：恢复时 rdb aof 那个恢复时间快rdb 因为其是数据的映射，直接载入到内存，而 aof 是命令，需要逐条运行 当一个值 100 次 incr 将产生 100 次记录， 下次恢复时从1次开始， 如何把它 直接到 100 次在某个瞬间逆化成命令 incr age 100次 set age 100注：aof 重写？aof 重写是把内存中的数据逆化成命令，写入 aof 日志里，以解决 aof 日志过大问题*（标识，真实文件中不存在）的配置文件 到了这个大小获取最终值，整个 aof 大小将减小bgrewriteaof 命令重写 +++++++++++++++++=========================== redis 服务器端命令： time 服务器时间dbsize 当前数据库 key 的数量 ++++++++++++================================= redis 主从配置： 服务器集群集群的作用： 主从备份，防止主机宕机 读写分离，分担 master 的任务 任务分离，如从服分别分担备份工作与计算工作 两种方式： 环形，线形线形的好处 ，直接切换到 slave1 不需要在链接 slave2 12345678910 sync[自动] &lt;---------------- dump 出rdb master ----------------&gt; slave 缓冲的aof ----------------&gt; replicationFeedSlaves ----------------&gt; : slave 连接到master 然后自动告知 同步（sync）一下，回送 数据映射的rdb 文件 ，在传rdb文件时，同时缓存的命令在 aof 中, 再同步到 slave一个进程保持联系 集群配置： 关闭 rdb 快照 (把备份工作交给 salve) 可以开启 aof salve 设置： 声明 salve-of 配置密码[如果master有密码] [某一个]salve 打开 rdb 快照功能 配置是否只读 [salve-read-only] 复制配置文件修改配置文件： redis6380.conf redis6381.conf 修改其中的 pidfile /..为redis63.pid port: 为63设置slave : 打开slaveof 添加ip 和端口 ：本地的话使用 127.0.0.1是否只读 salve-read-only no|yes只其中一个开启 rdb 快照，其余关闭 启动从服务器 redis-server redis6380.conf redis-cli -p 6380 连接6380端口添加密码： requirepass 密码进入后使用 auth 密码设置密码后，从服务器必须有密码才能连接到主服务器masterauth 密码 主从复制缺陷： 每次slave断开后(无论是主动的还是网络故障)再连接 master都要 master 全部 dump 出来 rdb 再 aof 即同步的过程都要重新执行一遍所以记住，多来 slave 不要一下全部启动，否则 master 可能 IO剧增 运维常用命令： time: 返回两个值 一个命令执行时的时间戳，一个执行完毕后过去多少微秒dbsize : 当前库中 有多少 keybgrewriteaof: 后台进程重写 aofbgsave: 后台保存 rdb 快照save: 保存 rdb 快照lastsave: 上次保存时间 返回时间戳slaveof: 设为 slave 服务器flushall: 清空所有 DBflushdb: 清空当前 DBshutdown: save|nosave 断开连接，关闭服务器slowlog: 显示慢查询info: 显示服务器信息config get: 获取配置信息config set: 设置配置信息monitor: 打开控制台sync: 主从同步client list: 客户端列表client kill 关闭某个客户端client setname 为某个客户端设置名字client getname 获取客户端名字 慢日志： slowlog 多慢才叫慢由slowlog-log-slower-than 10000 来指定，单位微妙 服务器存储多少条慢查询的记录： slowlog-max-len 128 来做限制slowlog get N 获取慢日志 =================================== aof 恢复 与 rdb 服务器迁移 当不小心 flushdb、 flushall时，立即shudowm nosave(这条任务不要写到aof文件中),防止其他访问，导致aof重写，到aof文件中删除这条命令redis-check-dump 检查rdb文件是否存在错误（重）在 redis 进程运行时，rdb 处于打开状态，这时因为占据同样的句柄，rdb 不可用 sentinel 运维监控（官方自带的） 手动操作： config get 选项 config set 选项 运行时：更改 master-slave修改一台 slave 为 master 1) 命令该服务，不做其他 redis 的 slave命令：slaveof no one 2) 修改 salve-read-only 为 no命令：config set salve-read-only no其他的 slave 再指向 这个 new master A 1）命令该服务为 new master A 的 slave命令: slaveofIP port 注：slaveof 127.0.0.1 6379 sentinel做的就是以上操作，不断与 master 通信， 当master 不回应，就切换其中一个为master 监控配置： sentinel monitor def_master 127.0.0.1 6379 2(结合三十秒，监控到2次连不上才是失效)sentinel auth-pass def-master 012_345^678-90 master 要不要密码 ！master 被当前 sentinel 实例 认定为 失效的间隔时间！如果当前的 sentinel 与 master 直接的通讯中，在指定的时间内，没有响应或者响应错误代码，那么当前 sentinel 就认为master 失效，（SDOWN 主观失效） 默认为 30 秒sentinel down-after-millseconds def_master 30000 当前 sentinel 实例是否允许实施 failover (故障转移)no 表示当前 sentinel 为观察者(只参与投票，不参与实施 failover )全局中至少有一个yessentinel can-failover def_master yes 监控到失效 允不允许把slave 改为master 在多个sentinel监控时，只一个有权利修改为masterfailover notification-script mymaster /var/redis/notify.shparallel-syncs mymaster 1 同时几台连接到新的 master (如果瞬间全部连接，ＩＯ激增，容易GG) 配置文件： sentinel.conf （windows好像没有）redis-server sentinel.conf –sentinel 启动sentinel 进程 在 配置文件中，slave-priority 100 数字越小优先级最高 改完优先把优先级高的作为新的 master ++++++++++++++++++++++++++++++++++++ 实际开发技巧：key-value 与传统的 关系型数据库有何关联 如何 key 设计 书签系统： create table book( book_id int, title char(20))engine myisam charset utf8; redis 键值设置：1）把表名转换为key 前缀2）主键3）主键值4) 写要存储的列名set user:id:4:name 小明 无底洞效应:… 如何使用username 查询，只能冗余信息set user:username:lisi:userid 9 维护一个相互引用的数据通过 userid 查 name,mail ,age …不会导致很多冗余，只是 保存 id 世上安得双修法，不负如来不负卿。。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://blog.wddog.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.wddog.cn/tags/Redis/"}]},{"title":"php 生成唯一订单的 6 种方法","slug":"PHP生成唯一订单的 6 种方法","date":"2018-03-09T15:09:06.266Z","updated":"2018-03-09T15:16:57.112Z","comments":true,"path":"2018/03/09/PHP生成唯一订单的 6 种方法/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/PHP生成唯一订单的 6 种方法/","excerpt":"","text":"PHP生成唯一订单号其实是非常的简单了我们随便就可以整理多种生成方式了，这里小编整理了6种方式供各位参考。 做商城类项目经常需要生成唯一订单号，下面来个汇总！ 方法一:1return date('Ymd') . str_pad(mt_rand(1, 99999), 5, '0', STR_PAD_LEFT); 方法二:1234567891011121314151617/** * * uniqid - 官方是这样说的： * Gets a prefixed unique identifier based on the current time in microseconds. */ function build_order_no() &#123; return date('Ymd').&lt;a href=\"/tags.php/substr/\" target=\"_blank\"&gt;substr&lt;/a&gt;(implode(NULL, array_map('ord', str_split(substr(uniqid(), 7, 13), 1))), 0, 8); &#125; 用uniqid获取一个基于当前的微秒数生成的唯一不重复的字符串（但是他的前7位貌似很久才会发生变动，所以不用考虑可删除），取其第8到13位。但是这个字符串里面有英文字母，咋办？ 用ord获取他的ASCII码，所以就有了下一步：用str_split把这个字符串分割为数组，用array_map去操作（速度快点）。 然后返回的还是一个数组，KO，在用implode弄成字符串，但是字符长度不定，取前固定的几位，然后前面加上当前的年份和日期，这个方法生成的订单号，全世界不会有多少重复的。 当然，除非你把服务器时间往前调，但是调也不用怕，哥不相信他会在同一微秒内下两次订单，网络数据传输也要点时间的，即便你是在本地。 方法三:12345678910111213public function make_order($user_id) &#123; return mt_rand(10,99) . sprintf('%010d',time() - 946656000) . sprintf('%03d', (float) microtime() * 1000) . sprintf('%03d', (int) $user_id % 1000); &#125; 方法四: 我是比较喜欢这种方式的(O(∩_∩)O哈哈~)1234$yCode = array('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'); $orderSn = $yCode[intval(date('Y')) - 2011] . strtoupper(dechex(date('m'))) . date('d') . substr(time(), -5) . substr(microtime(), 2, 5) . sprintf('%02d', rand(0, 99 )); 方法五 生成24位唯一订单号码:123456789101112131415161718192021//生成24位唯一订单号码，格式：YYYY-MMDD-HHII-SS-NNNN,NNNN-CC，其中：YYYY=年份，MM=月份，DD=日期，HH=24格式小时，II=分，SS=秒，NNNNNNNN=随机数，CC=检查码 @date_default_timezone_set(\"PRC\"); while(true)&#123; //订购日期 $order_date = date('Y-m-d'); //订单号码主体（YYYYMMDDHHIISSNNNNNNNN） $order_id_main = date('YmdHis') . rand(10000000,99999999); //订单号码主体长度 $order_id_len = strlen($order_id_main); $order_id_sum = 0; for($i=0; $i&lt;$order_id_len; $i++)&#123; $order_id_sum += (int)(substr($order_id_main,$i,1)); &#125; //唯一订单号码（YYYYMMDDHHIISSNNNNNNNNCC） $order_id = $order_id_main . str_pad((100 - $order_id_sum % 100) % 100,2,'0',STR_PAD_LEFT); if($result = sqlite_query($db,\"SELECT * FROM orders WHERE order_id='$order_id'\"))&#123; if(sqlite_num_rows($result) == 0)&#123; break; &#125; &#125; 例子六:12345678910111213141516171819/** * 生成16位纯数字订单号 * 最大支持时间到 2056-12-31 23:59:59 * * @access public * @return string //phpfensi.com */ public static function getOrderSN() &#123; return (date('y') + date('m') + date('d')) . str_pad((time() - &lt;a href=\"/tags.php/strtotime/\" target=\"_blank\"&gt;strtotime&lt;/a&gt;(date('Y-m-d'))), 5, 0, STR_PAD_LEFT) . substr(microtime(), 2, 6) . sprintf('%03d', rand(0, 999)); &#125; 目前在用的,基本保证不重复了,能用到2056年,觉得应该够了,以后有需求再扩展.","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"Mysql 忘记密码解决与用户创建，授权详解","slug":"Mysql小技巧","date":"2018-03-09T10:54:48.450Z","updated":"2018-03-09T12:47:29.576Z","comments":true,"path":"2018/03/09/Mysql小技巧/","link":"","permalink":"http://blog.wddog.cn/2018/03/09/Mysql小技巧/","excerpt":"","text":"当你忘记 Mysql 密码时，又能操作 服务器 (Linux) 时 就能很简单的重设密码，下面就和我一起学习吧！ 一、Mysql 绕过密码登录1. KILL掉系统里的MySQL进程；2. 用以下命令启动MySQL，以不检查权限的方式启动；1mysqld_safe --skip-grant-tables &amp; 3. 然后用空密码方式使用root用户登录 MySQL；1mysql -u root 4. 修改 root 用户密码123mysql&gt; update mysql.user set password=PASSWORD（&apos;123456&apos;） where User=root and host=&apos;localhost&apos;；mysql&gt; flush privileges； // 把配置写入内存 生效mysql&gt; quit 5. 重新启动MySQL，就可以使用新密码登录了。1mysql -u root -p123456 二、MySQL添加新用户、为用户创建数据库、为新用户分配权限登录MySQL12mysql -u root -p 添加新用户允许本地 IP 访问 localhost, 127.0.0.1 1create user &apos;test&apos;@&apos;localhost&apos; identified by &apos;123456&apos;; 允许外网 IP 访问1create user &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;; 刷新授权1flush privileges; 为用户创建数据库1create database test DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 为新用户分配权限授予用户通过外网IP对于该数据库的全部权限1grant all privileges on `testdb`.* to &apos;test&apos;@&apos;%&apos; identified by &apos;123456&apos;; 授予用户在本地服务器对该数据库的全部权限1grant all privileges on `testdb`.* to &apos;test&apos;@&apos;localhost&apos; identified by &apos;123456&apos;; 刷新权限1flush privileges; 退出 root 重新登录1exit 用新帐号 test 重新登录，由于使用的是 % 任意IP连接，所以需要指定外部访问IP1mysql -u test -h 115.28.203.224 -p 在Ubuntu服务器下，MySQL默认是只允许本地登录，因此需要修改配置文件将地址绑定给注释掉： 123# Instead of skip-networking the default is now to listen only on # localhost which is more compatible and is not less secure. #bind-address = 127.0.0.1 #注释掉这一行就可以远程登录了 不然会报如下错误： ERROR 2003 (HY000): Can’t connect to MySQL server on ‘host’ (111)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wddog.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.wddog.cn/tags/Mysql/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.wddog.cn/tags/PHP/"}]},{"title":"又重新搭建了一个博客，此次使用 Hexo + Github 搭建","slug":"前言","date":"2018-03-05T10:42:08.835Z","updated":"2018-03-06T03:32:31.908Z","comments":true,"path":"2018/03/05/前言/","link":"","permalink":"http://blog.wddog.cn/2018/03/05/前言/","excerpt":"","text":"使用 Hexo 搭建个人博客还是很简单的，极其轻松，使用也简单，最好的是你甚至不需要 域名，也不需要服务器，在 Github上注册一个账号，你就能很快的搭建一个好看又好用的博客了，这对学生党而言就是福音了，毕竟穷(我也一脸穷苦相，妈耶！) 前言Hexo 的文章格式也极其简单，使用的 Markdown 标记语言,你只需要记住几个简单的标记，就能满足日常使用的。。。(不像 HTML 那一堆的标记，简直记得头大)接下来就告诉你一些 简单 Markdown 快 get 到自己的 Blog 吧 一、标题123456# 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题 效果如下：一级标题二级标题三级标题四级标题五级标题六级标题二、列表Markdown 支持有序列表和无序列表。 无序列表使用-、+和*作为列表标记：1234567891011- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue 效果如下： Red Green Blue 有序列表则使用数字加英文句点.来表示：1231. Red2. Green3. Blue 效果如下： Red Green Blue 三、引用引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 常见的引用写法： 12345678910111213141516171819&gt; 这是一段引用 //在`&gt;`后面有 1 个空格&gt; &gt; 这是引用的代码块形式 //在`&gt;`后面有 5 个空格&gt; &gt; 代码例子：&gt; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; #### 这是一个四级标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项 效果如下： 这是一段引用 //在&gt;后面有 1 个空格 这是引用的代码块形式 //在`&gt;`后面有 5 个空格 代码例子： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 一级引用 二级引用 三级引用 这是一个四级标题 这是第一行列表项 这是第二行列表项 四、强调两个或-代表加粗，一个或-代表斜体，~~代表删除。 12345**加粗文本** 或者 __加粗文本__*斜体文本* 或者_斜体文本_~~删除文本~~ 效果如下：加粗文本 或者 加粗文本 斜体文本 或者斜体文本 删除文本 五、图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式： 123图片：![]() ![图片文本(可忽略)](图片地址)链接：[]() [链接文本](链接地址) 链接又分为行内式、参考式和 自动链接： 12345678910111213这是行内式链接：[ConnorLin&apos;s Blog](http://connorlin.github.io)。这是参考式链接：[ConnorLin&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。[url]: http://connorlin.github.io/ &quot;ConnorLin&apos;s Blog&quot;链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略)这是自动链接：直接使用`&lt;&gt;`括起来&lt;http://connorlin.github.io&gt;这是图片：![][avatar][avatar]: https://connorlin.github.io/images/avatar.jpg 效果如下：这是行内式链接：ConnorLin’s Blog。 这是参考式链接：ConnorLin’s Blog，其中url为链接标记，可置于文中任意位置。 链接标记格式为：[链接标记文本]: 链接地址 链接title(可忽略) 这是自动链接：直接使用&lt;&gt;括起来http://connorlin.github.io 这是图片： 六、代码代码分为行内代码和代码块。 行内代码使用 代码 标识，可嵌入文字中 代码块使用4个空格或12 这里是代码123456代码语法高亮在 ```后面加上空格和语言名称即可``` 语言//注意语言前面有空格这里是代码 例如： 12345678910这是行内代码`onCreate(Bundle savedInstanceState)`的例子。这是代码块和语法高亮：``` java// 注意java前面有空格protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125; 效果如下：这是行内代码onCreate(Bundle savedInstanceState)的例子。 这是代码块和语法高亮： 1234if(true)&#123; echo \"我真是一个又帅又令人发情的 Boy\";&#125; 七、表格表格对齐格式 居左：:—- 居中：:—-:或—– 居右：—-: 例子： 123456|标题|标题|标题||:---|:---:|---:||居左测试文本|居中测试文本|居右测试文本||居左测试文本1|居中测试文本2|居右测试文本3||居左测试文本11|居中测试文本22|居右测试文本33||居左测试文本111|居中测试文本222|居右测试文本333| 效果如下： 标题 标题 标题 居左测试文本 居中测试文本 居右测试文本 居左测试文本1 居中测试文本2 居右测试文本3 居左测试文本11 居中测试文本22 居右测试文本33 居左测试文本111 居中测试文本222 居右测试文本333 八、分割线在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。 12345***---___* * * 效果均为一条分割线： 九、换行在行尾添加两个空格加回车表示换行： 1这是一行后面加两个空格 换行 效果如下：这是一行后面加两个空格换行 十、脚注(注解)使用[^]来定义脚注： 123这是一个脚注的例子[^1][^1]: 这里是脚注 效果如下：这是一个脚注的例子[^1] 扩展：常用弥补Markdown的Html标签字体12&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt; 效果如下：字体及字体颜色和大小字体颜色 换行 1使用html标签`&lt;br/&gt;`&lt;br/&gt;换行 效果如下：使用html标签换行 文本对齐方式 123&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt; 效果如下：居左文本居中文本居右文本 下划线 1&lt;u&gt;下划线文本&lt;/u&gt; 效果如下：下划线文本 That’s all, Enjoy it!","categories":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"http://blog.wddog.cn/categories/Hexo教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.wddog.cn/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://blog.wddog.cn/tags/Github/"}]}]}